diff --git a/klippy/extras/TJC3224.py b/klippy/extras/TJC3224.py
new file mode 100644
index 000000000..ec5fd0dc5
--- /dev/null
+++ b/klippy/extras/TJC3224.py
@@ -0,0 +1,628 @@
+import time
+import math
+
+class TJC3224_LCD:
+    """
+    Class representing the control interface for a TJC3224 LCD display.
+
+    This class is based on the T5UIC1_LCD class from the DWIN_T5UIC1_LCD
+    repository available on (https://github.com/odwdinc/DWIN_T5UIC1_LCD)
+    for the TJC3224_011N display (3.2 inch, 240x320 pixels, no touch) used
+    on 3d printers from creality. Most of the instructions are compatible
+    with DWIN T5L instruction set available on the manufacturer website
+    (https://www.dwin-global.com/uploads/T5L_TA-Instruction-Set-Development-Guide.pdf)
+    """
+
+    # Display resolution
+    screen_width = 240
+    screen_height = 320
+
+    # Data frame structure
+    data_frame_head = b"\xAA"
+    data_frame_tail = [0xCC, 0x33, 0xC3, 0x3C]
+    data_frame = []
+
+    # Font size registers (for unicode and 8 bit text mode)
+    font_8x8 = 0x00
+    font_6x12 = 0x01
+    font_8x16 = 0x02
+    font_12x24 = 0x03
+    font_16x32 = 0x04
+    font_20x40 = 0x05
+    font_24x48 = 0x06
+    font_28x56 = 0x07
+    font_32x64 = 0x08
+
+    # Colors
+    color_white = 0xFFFF
+    color_black = 0x0000
+
+    # Instructions
+    cmd_handshake = 0x00
+    cmd_draw_value = 0x14
+    cmd_set_palette = 0x40
+    cmd_draw_line = 0x51
+    cmd_clear_screen = 0x52
+    cmd_draw_rectangle = 0x59
+    cmd_fill_rectangle = 0x5B
+    cmd_reverse_color_area = 0x5C
+    cmd_backlight_brightness = 0x5F
+    cmd_show_image = 0x70
+    cmd_move_screen_area = 0x09
+    cmd_draw_icon = 0x97
+    cmd_draw_text = 0x98
+
+    # Alias for extra commands
+    direction_up = 0x02
+    direction_down = 0x03
+
+    def __init__(self, serial):
+        """
+        Initializes the TJC3224_LCD object.
+
+        Args:
+            serial : Serial object to send messages.
+        """
+        self.serial = serial
+    
+    def init_display(self):
+        print("Sending handshake... ")
+        while not self.handshake():
+            pass
+        print("Handshake response: OK.")
+
+    def byte(self, bool_val):
+        """
+        Appends a single-byte value to the data frame.
+
+        :param bval: The byte value to be appended.
+        :type bval: int
+        """
+        self.data_frame += int(bool_val).to_bytes(1, byteorder="big")
+
+    def word(self, word_val):
+        """
+        Appends a two-byte value to the data frame.
+
+        :param wval: The two-byte value to be appended.
+        :type wval: int
+        """
+        self.data_frame += int(word_val).to_bytes(2, byteorder="big")
+
+    def long(self, long_val):
+        """
+        Appends a four-byte value to the data frame.
+
+        :param lval: The four-byte value to be appended.
+        :type lval: int
+        """
+        self.data_frame += int(long_val).to_bytes(4, byteorder="big")
+
+    def double_64(self, double_val):
+        """
+        Appends an eight-byte value to the data frame.
+
+        :param dval: The eight-byte value to be appended.
+        :type value: int
+        """
+        self.data_frame += int(double_val).to_bytes(8, byteorder="big")
+
+    def string(self, string):
+        """
+        Appends a UTF-8 encoded string to the data frame.
+
+        :param string: The string to be appended.
+        :type string: str
+        """
+        self.data_frame += string.encode("utf-8")
+
+    def send(self):
+        """
+        Sends the prepared data frame to the display according to the T5L_TA serial protocol.
+
+        Sends the current contents of the data frame, followed by a predefined
+        tail sequence. After sending, the data frame is reset to the head sequence.
+        """
+        # Write the current data frame and tail sequence to the serial connection
+        self.serial.write(self.data_frame)
+        self.serial.write(self.data_frame_tail)
+
+        # Reset the data frame to the head sequence for the next transmission
+        self.data_frame = self.data_frame_head
+
+        # Delay to allow for proper transmission
+        time.sleep(0.001)
+
+    def handshake(self):
+        """
+        Perform a handshake with the display.
+
+        :return: True if handshake is successful, otherwise False.
+        :rtype: bool
+        """
+        # Send the initiation byte (0x00)
+        self.byte(self.cmd_handshake)
+        self.send()
+        time.sleep(0.1)
+
+        return True
+
+    def set_backlight_brightness(self, brightness):
+        """
+        Set the backlight luminance.
+
+        :param luminance: Luminance level (0x00-0x40).
+        :type luminance: int
+        """
+        self.byte(self.cmd_backlight_brightness)
+        self.byte(min(brightness, 0x40))
+        self.send()
+
+    def set_palette(self, background_color=color_black, foreground_color=color_white):
+        """
+        Set the palette colors for drawing functions.
+
+        :param bg_color: Background color.
+        :type bg_color: int
+        :param front_color: Foreground (text) color.
+        :type front_color: int
+        """
+        self.byte(self.cmd_set_palette)
+        self.word(foreground_color)
+        self.word(background_color)
+        self.send()
+
+    def clear_screen(self, color=color_black):
+        """
+        Clear the screen with a specified color.
+
+        :param color: Background color.
+        :type color: int
+        """
+        self.set_palette(color)
+        self.byte(self.cmd_clear_screen)
+        self.send()
+
+    def draw_point(self, color, x, y):
+        """
+        Draw a point on the screen.
+
+        :param Color: Color of the point.
+        :type Color: int
+        :param x: X-coordinate of the point.
+        :type x: int
+        :param y: Y-coordinate of the point.
+        :type y: int
+        """
+        self.set_palette(self.color_white, color)
+        self.byte(self.cmd_draw_line)
+        self.word(int(x))
+        self.word(int(y))
+        self.send()
+
+    def draw_line(self, color, x_start, y_start, x_end, y_end):
+        """
+        Draw a line segment on the screen.
+
+        :param color: Line segment color.
+        :type color: int
+        :param x_start: X-coordinate of the starting point.
+        :type x_start: int
+        :param y_start: Y-coordinate of the starting point.
+        :type y_start: int
+        :param x_end: X-coordinate of the ending point.
+        :type x_end: int
+        :param y_end: Y-coordinate of the ending point.
+        :type y_end: int
+        """
+        self.set_palette(self.color_white, color)
+        self.byte(self.cmd_draw_line)
+        self.word(x_start)
+        self.word(y_start)
+        self.word(x_end)
+        self.word(y_end)
+        self.send()
+
+    def draw_rectangle(self, mode, color, x_start, y_start, x_end, y_end):
+        """
+        Draw a rectangle on the screen.
+
+        :param mode: 0=frame, 1=fill, 2=XOR fill.
+        :type mode: int
+        :param color: Rectangle color.
+        :type color: int
+        :param x_start: X-coordinate of the upper-left point.
+        :type x_start: int
+        :param y_start: Y-coordinate of the upper-left point.
+        :type y_start: int
+        :param x_end: X-coordinate of the lower-right point.
+        :type x_end: int
+        :param y_end: Y-coordinate of the lower-right point.
+        :type y_end: int
+        """
+        self.set_palette(self.color_white, color)
+        mode_to_command = {
+            0: self.cmd_draw_rectangle,
+            1: self.cmd_fill_rectangle,
+            2: self.cmd_reverse_color_area,
+        }
+        command = mode_to_command.get(mode, 0)
+        self.byte(command)
+        self.word(x_start)
+        self.word(y_start)
+        self.word(x_end)
+        self.word(y_end)
+        self.send()
+
+    def draw_circle(self, color, x_center, y_center, r):
+        """
+        Draw a circle on the screen using the draw points method.
+
+        :param Color: Circle color.
+        :type Color: int
+        :param x_center: X-coordinate of the center of the circle.
+        :type x_center: int
+        :param y_center: Y-coordinate of the center of the circle.
+        :type y_center: int
+        :param r: Circle radius.
+        :type r: int
+        """
+        b = 0
+        a = 0
+        while a <= b:
+            b = math.sqrt(r * r - a * a)
+            while a == 0:
+                b = b - 1
+                break
+            self.draw_point(
+                color, 1, 1, x_center + a, y_center + b
+            )  # Draw some sector 1
+            self.draw_point(
+                color, 1, 1, x_center + b, y_center + a
+            )  # Draw some sector 2
+            self.draw_point(
+                color, 1, 1, x_center + b, y_center - a
+            )  # Draw some sector 3
+            self.draw_point(
+                color, 1, 1, x_center + a, y_center - b
+            )  # Draw some sector 4
+
+            self.draw_point(
+                color, 1, 1, x_center - a, y_center - b
+            )  # Draw some sector 5
+            self.draw_point(
+                color, 1, 1, x_center - b, y_center - a
+            )  # Draw some sector 6
+            self.draw_point(
+                color, 1, 1, x_center - b, y_center + a
+            )  # Draw some sector 7
+            self.draw_point(
+                color, 1, 1, x_center - a, y_center + b
+            )  # Draw some sector 8
+            a += 1
+
+    def fill_circle(self, font_color, x_center, y_center, r):
+        """
+        Fill a circle with a color.
+
+        :param font_color: Fill color.
+        :type font_color: int
+        :param x_center: X-coordinate of the center of the circle.
+        :type x_center: int
+        :param y_center: Y-coordinate of the center of the circle.
+        :type y_center: int
+        :param r: Circle radius.
+        :type r: int
+        """
+        b = 0
+        for i in range(r, 0, -1):
+            a = 0
+            while a <= b:
+                b = math.sqrt(i * i - a * a)
+                while a == 0:
+                    b = b - 1
+                    break
+                self.draw_point(
+                    font_color, 2, 2, x_center + a, y_center + b
+                )  # Draw some sector 1
+                self.draw_point(
+                    font_color, 2, 2, x_center + b, y_center + a
+                )  # raw some sector 2
+                self.draw_point(
+                    font_color, 2, 2, x_center + b, y_center - a
+                )  # Draw some sector 3
+                self.draw_point(
+                    font_color, 2, 2, x_center + a, y_center - b
+                )  # Draw some sector 4
+
+                self.draw_point(
+                    font_color, 2, 2, x_center - a, y_center - b
+                )  # Draw some sector 5
+                self.draw_point(
+                    font_color, 2, 2, x_center - b, y_center - a
+                )  # Draw some sector 6
+                self.draw_point(
+                    font_color, 2, 2, x_center - b, y_center + a
+                )  # Draw some sector 7
+                self.draw_point(
+                    font_color, 2, 2, x_center - a, y_center + b
+                )  # Draw some sector 8
+                a = a + 2
+
+    def draw_string(
+        self, show_background, size, font_color, background_color, x, y, string
+    ):
+        """
+        Draw a string on the screen.
+
+        :param show_background: True to display the background color, False to not display the background color.
+        :type show_background: bool
+        :param size: Font size.
+        :type size: int
+        :param font_color: Character color.
+        :type font_color: int
+        :param background_color: Background color.
+        :type background_color: int
+        :param x: X-coordinate of the upper-left point.
+        :type x: int
+        :param y: Y-coordinate of the upper-left point.
+        :type y: int
+        :param string: The string to be drawn.
+        :type string: str
+        """
+        self.byte(self.cmd_draw_text)
+        self.word(x)
+        self.word(y)
+        self.byte(0x00)  # font
+        self.byte(0x02 | (show_background * 0x40))  # mode (bshow)
+        self.byte(size)  # size
+        self.word(font_color)
+        self.word(background_color)
+        self.string(string)
+        self.send()
+
+    def draw_int_value(
+        self,
+        show_background,
+        zeroFill,
+        zeroMode,
+        font_size,
+        color,
+        background_color,
+        iNum,
+        x,
+        y,
+        value,
+    ):
+        """
+        Draw a positive integer value on the screen.
+
+        :param show_background: True to display the background color, False to not display the background color.
+        :type show_background: bool
+        :param zeroFill: True to zero fill, False for no zero fill.
+        :type zeroFill: bool
+        :param zeroMode: 1 for leading 0 displayed as 0, 0 for leading 0 displayed as a space.
+        :type zeroMode: int
+        :param font_size: Font size.
+        :type font_size: int
+        :param color: Character color.
+        :type color: int
+        :param background_color: Background color.
+        :type background_color: int
+        :param iNum: Number of digits.
+        :type iNum: int
+        :param x: X-coordinate of the upper-left point.
+        :type x: int
+        :param y: Y-coordinate of the upper-left point.
+        :type y: int
+        :param value: Integer value.
+        :type value: int
+        """
+        self.byte(0x14)
+        # Bit 7: bshow
+        # Bit 6: 1 = signed; 0 = unsigned number;
+        # Bit 5: zeroFill
+        # Bit 4: zeroMode
+        # Bit 3-0: size
+        self.byte(
+            (show_background * 0x80)
+            | (0 * 0x40)
+            | (zeroFill * 0x20)
+            | (zeroMode * 0x10)
+            | font_size
+        )
+        self.word(color)
+        self.word(background_color)
+        self.byte(iNum)
+        self.byte(0)  # fNum
+        self.word(x)
+        self.word(y)
+        self.double_64(value)
+        self.send()
+
+    def draw_float_value(
+        self,
+        show_background,
+        zeroFill,
+        zeroMode,
+        size,
+        color,
+        background_color,
+        iNum,
+        fNum,
+        x,
+        y,
+        value,
+    ):
+        """
+        Draw a floating point number on the screen.
+
+        :param show_background: True to display the background color, False to not display the background color.
+        :type show_background: bool
+        :param zeroFill: True to zero fill, False for no zero fill.
+        :type zeroFill: bool
+        :param zeroMode: 1 for leading 0 displayed as 0, 0 for leading 0 displayed as a space.
+        :type zeroMode: int
+        :param size: Font size.
+        :type size: int
+        :param color: Character color.
+        :type color: int
+        :param background_color: Background color.
+        :type background_color: int
+        :param iNum: Number of whole digits.
+        :type iNum: int
+        :param fNum: Number of decimal digits.
+        :type fNum: int
+        :param x: X-coordinate of the upper-left point.
+        :type x: int
+        :param y: Y-coordinate of the upper-left point.
+        :type y: int
+        :param value: Float value.
+        :type value: float
+        """
+        self.byte(self.cmd_draw_value)
+        # Bit 7: bshow
+        # Bit 6: 1 = signed; 0 = unsigned number;
+        # Bit 5: zeroFill
+        # Bit 4: zeroMode
+        # Bit 3-0: size
+        self.byte(
+            (show_background * 0x80)
+            | (0 * 0x40)
+            | (zeroFill * 0x20)
+            | (zeroMode * 0x10)
+            | size
+        )
+        self.word(color)
+        self.word(background_color)
+        self.byte(iNum)
+        self.byte(fNum)
+        self.word(x)
+        self.word(y)
+        self.long(value)
+        self.send()
+
+    def draw_signed_float(
+        self, show_background, size, color, background_color, iNum, fNum, x, y, value
+    ):
+        """
+        Draw a signed floating-point number on the screen.
+
+        :param size: Font size.
+        :type size: int
+        :param background_color: Background color.
+        :type background_color: int
+        :param iNum: Number of whole digits.
+        :type iNum: int
+        :param fNum: Number of decimal digits.
+        :type fNum: int
+        :param x: X-coordinate of the upper-left corner.
+        :type x: int
+        :param y: Y-coordinate of the upper-left corner.
+        :type y: int
+        :param value: Floating-point value to be displayed.
+        :type value: float
+        """
+        if value < 0:
+            self.draw_string(
+                show_background, size, color, background_color, x - 6, y - 3, "-"
+            )
+            self.draw_float_value(
+                show_background,
+                False,
+                0,
+                size,
+                color,
+                background_color,
+                iNum,
+                fNum,
+                x,
+                y,
+                -value,
+            )
+        else:
+            self.draw_string(
+                show_background, size, color, background_color, x - 6, y - 3, " "
+            )
+            self.draw_float_value(
+                show_background,
+                False,
+                0,
+                size,
+                color,
+                background_color,
+                iNum,
+                fNum,
+                x,
+                y,
+                value,
+            )
+
+    def draw_icon(self, show_background, libID, picID, x, y):
+        """
+        Draw an icon on the screen.
+
+        :param show_background: True to display the background color, False to not display the background color.
+        :type show_background: bool
+        :param libID: Icon library ID.
+        :type libID: int
+        :param picID: Icon ID.
+        :type picID: int
+        :param x: X-coordinate of the upper-left corner.
+        :type x: int
+        :param y: Y-coordinate of the upper-left corner.
+        :type y: int
+        """
+        if x > self.screen_width - 1:
+            x = self.screen_width - 1
+        if y > self.screen_height - 1:
+            y = self.screen_height - 1
+        self.byte(self.cmd_draw_icon)
+        self.word(x)
+        self.word(y)
+        self.byte(libID)
+        self.byte(show_background * 0x01)
+        self.word(picID)
+        self.send()
+
+    def draw_image(self, id=1):
+        """
+        Draw a JPG image on the screen and cache it in the virtual display area.
+
+        :param id: Picture ID.
+        :type id: int
+        """
+        self.byte(self.cmd_show_image)
+        self.byte(id)
+        self.send()
+
+    def move_screen_area(
+        self, direction, offset, background_color, x_start, y_start, x_end, y_end
+    ):
+        """
+        Copy an area from the virtual display area to the current screen.
+
+        :param direction: Direction ( 0 = ,1 =, 0x02= top, 0x03 = down)
+        :type direction: int
+        :param offset: How many pixels the copied area is going to be moved.
+        :type offset: int
+        :param offset: Color of background (to fill the previously moved area?).
+        :type offset: int
+        :param x_start: X-coordinate of the upper-left corner of the virtual area.
+        :type x_start: int
+        :param y_start: Y-coordinate of the upper-left corner of the virtual area.
+        :type y_start: int
+        :param x_end: X-coordinate of the lower-right corner of the virtual area.
+        :type x_end: int
+        :param y_end: Y-coordinate of the lower-right corner of the virtual area.
+        :type y_end: int
+        """
+        self.byte(self.cmd_move_screen_area)
+        self.byte(0x80 | direction)
+        self.word(offset)
+        self.word(background_color)
+        self.word(x_start)
+        self.word(y_start)
+        self.word(x_end)
+        self.word(y_end)
+        self.send()
diff --git a/klippy/extras/dirzctl.py b/klippy/extras/dirzctl.py
new file mode 100644
index 000000000..b9fe4642f
--- /dev/null
+++ b/klippy/extras/dirzctl.py
@@ -0,0 +1,111 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import mcu
+import time
+
+class DirZCtl:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu', 'mcu'))
+        self.oid = self.mcu.create_oid()
+        self.steppers = []
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_dirzctl, "debug_dirzctl", self.oid)
+        self.mcu.register_response(self._handle_result_dirzctl, "result_dirzctl", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode = self.printer.lookup_object("gcode")
+        self.gcode.register_command('DIRZCTL', self.cmd_DIRZCTL, desc=self.cmd_DIRZCTL_help)
+        self.all_params = []
+        self.hx711s = None
+        self.mcu_freq = 72000000
+        self.step_base = config.getfloat('step_base', default=2, minval=1, maxval=6)
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _handle_mcu_identify(self):
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.steppers = []
+        self.toolhead = self.printer.lookup_object('toolhead')
+        for stepper in self.toolhead.get_kinematics().get_steppers():
+            if stepper.is_active_axis('z'):
+                self.steppers.append(stepper)
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')   
+
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        # "heart_beat_dirzctl oid=%c",
+        # "heart_beat_dirzctl_result oid=%c",
+        # oid=self.oid, cq=None)
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_dirzctl oid=%d z_count=%d" % (self.oid, len(self.steppers)))
+        for i in range(len(self.steppers)):
+            dir_pin, step_pin, ivt_dir, ivt_step = self.steppers[i].get_pin_info()
+            self.mcu.add_config_cmd("add_dirzctl oid=%d index=%d dir_pin=%s step_pin=%s dir_invert=%d step_invert=%d" % (self.oid, i, dir_pin, step_pin, ivt_dir, ivt_step))
+
+        # self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u is_ck_con=%c", cq=None)
+        self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u", cq=None)
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+    
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_debug_dirzctl(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_result_dirzctl(self, params):
+        self.all_params.append(params)
+        # self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def get_params(self):
+        return self.all_params, (self.all_params[0]['tick'] if len(self.all_params) > 0 else 0)
+
+    def check_and_run(self, direct, step_us, step_cnt, wait_finish=True, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if step_cnt != 0:
+            self.all_params = []
+        # self.run_cmd.send([self.oid, direct, step_us, step_cnt, 1 if is_ck_con else 0])
+        self.run_cmd.send([self.oid, direct, step_us, step_cnt])
+        t_start = time.time()
+        while not (self.is_shutdown or self.is_timeout) and wait_finish and ((time.time() - t_start) < (1.5 * 1000 * 1000 * step_us * step_cnt)) and len(self.all_params) != 2:
+            self.hx711s.delay_s(0.05)
+        pass
+
+    def send_heart_beat(self):
+        #if time.time() - self.last_send_heart > 0.1:
+        #    self.send_heart_beat_cmd.send([self.oid])
+        #    self.last_send_heart = time.time()
+        pass
+
+    cmd_DIRZCTL_help = "Test DIRZCTL."
+    # DIRZCTL DIRECT=1 STEP_US=1500 STEP_CNT=100
+    def cmd_DIRZCTL(self, gcmd):
+        index = gcmd.get_int('INDEX', len(self.steppers), minval=0, maxval=len(self.steppers))
+        direct = gcmd.get_int('DIRECT', 1, minval=0, maxval=1)
+        step_us = gcmd.get_int('STEP_US', 1500, minval=4, maxval=100000)
+        step_cnt = gcmd.get_int('STEP_CNT', 256, minval=0, maxval=10000)
+        self.check_and_run(direct, step_us, step_cnt, False, False)
+        pass
+
+
+def load_config(config):
+    return DirZCtl(config)
diff --git a/klippy/extras/e3v3se_display.py b/klippy/extras/e3v3se_display.py
new file mode 100644
index 000000000..735b7ebda
--- /dev/null
+++ b/klippy/extras/e3v3se_display.py
@@ -0,0 +1,3770 @@
+import logging
+import time
+from .display.menu_keys import MenuKeys
+from .TJC3224 import TJC3224_LCD
+from .printerInterface import PrinterData
+from .serial_bridge import PrinterSerialBridge
+
+def current_milli_time():
+    return round(time.time() * 1000)
+
+
+def _MAX(lhs, rhs):
+    if lhs > rhs:
+        return lhs
+    else:
+        return rhs
+
+
+def _MIN(lhs, rhs):
+    if lhs < rhs:
+        return lhs
+    else:
+        return rhs
+
+
+class select_t:
+    now = 0
+    last = 0
+
+    def set(self, v):
+        self.now = self.last = v
+
+    def reset(self):
+        self.set(0)
+
+    def changed(self):
+        c = self.now != self.last
+        if c:
+            self.last = self.now
+            return c
+
+    def dec(self):
+        if self.now:
+            self.now -= 1
+        return self.changed()
+
+    def inc(self, v):
+        if self.now < (v - 1):
+            self.now += 1
+        else:
+            self.now = v - 1
+        return self.changed()  
+
+class E3V3SEMenuKeys(MenuKeys):
+    """
+    E3V3SEMenuKeys is a subclass of MenuKeys designed to 
+    customize initialization without modifying the original MenuKeys class.
+
+    This class defaults the pins for the menu keys to the corresponding
+    pins of the ender 3 v3 se 3d printer.
+    """
+    def __init__(self, config, callback):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.callback = callback
+        buttons = self.printer.load_object(config, "buttons")
+        # Register rotary encoder
+        encoder_pins = config.get('encoder_pins', '^PA12, ^PA11')
+        encoder_steps_per_detent = config.getchoice('encoder_steps_per_detent',
+                                                    {2: 2, 4: 4}, 4)
+        if encoder_pins is not None:
+            try:
+                pin1, pin2 = encoder_pins.split(',')
+            except:
+                raise config.error("Unable to parse encoder_pins")
+            buttons.register_rotary_encoder(pin1.strip(), pin2.strip(),
+                                            self.encoder_cw_callback,
+                                            self.encoder_ccw_callback,
+                                            encoder_steps_per_detent)
+        self.encoder_fast_rate = config.getfloat('encoder_fast_rate',
+                                                 .030, above=0.)
+        self.last_encoder_cw_eventtime = 0
+        self.last_encoder_ccw_eventtime = 0
+        # Register click button
+        self.is_short_click = False
+        self.click_timer = self.reactor.register_timer(self.long_click_event)
+        self.register_click_button(config, 'click_pin', self.click_callback, False,  '^!PB1')
+
+    def register_click_button(self, config, name, callback, push_only=True, default_value=None,):
+        pin = config.get(name, default_value)
+        if pin is None:
+            return
+        buttons = self.printer.lookup_object("buttons")
+        if config.get('analog_range_' + name, None) is None:
+            if push_only:
+                buttons.register_button_push(pin, callback)
+            else:
+                buttons.register_buttons([pin], callback)
+            return
+        amin, amax = config.getfloatlist('analog_range_' + name, count=2)
+        pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
+        if push_only:
+            buttons.register_adc_button_push(pin, amin, amax, pullup, callback)
+        else:
+            buttons.register_adc_button(pin, amin, amax, pullup, callback)
+
+
+class E3V3SEPrinterSerialBridge(PrinterSerialBridge):
+    """
+    E3V3SEPrinterSerialBridge is a subclass of PrinterSerialBridge designed to 
+    customize initialization without modifying the original PrinterSerialBridge class.
+
+    This class defaults the serial pins, baud, eol and serial bridge config to specific
+    values used for the ender 3 v3 se 3d printer.
+    """
+    def __init__(self, config):
+        self.callbacks = []
+        self.printer = config.get_printer()
+        self.name = config.get_name().split()[-1]
+        self.eol = config.get('eol', default='')
+        self._ready = False
+        self.baud = config.getint("baud", 115200)
+        self.serial_config = config.getint("config", 3)
+        self._logging = config.getboolean("logging", False)
+
+        self.reactor = self.printer.get_reactor()
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.printer.register_event_handler("klippy:disconnect",
+            self.handle_disconnect)
+
+        ppins = self.printer.lookup_object("pins")
+        pin_params = ppins.lookup_pin(config.get("tx_pin", 'PA2'))
+        rx_pin_params = ppins.lookup_pin(config.get("rx_pin" , 'PA3'))
+        self.mcu = pin_params['chip']
+        self.oid = self.mcu.create_oid()
+        self.mcu.register_config_callback(self.build_config)
+
+        self.input_buffer = ""
+
+        self.serial_bridge = self.printer.load_object(config, "serial_bridge")
+        self.serial_bridge.setup_bridge(self)
+
+
+class E3v3seDisplay:
+    
+    ENCODER_DIFF_NO = 0  # no state
+    ENCODER_DIFF_CW = 1  # clockwise rotation
+    ENCODER_DIFF_CCW = 2  # counterclockwise rotation
+    ENCODER_DIFF_ENTER = 3  # click
+
+    TROWS = 6
+    MROWS = TROWS - 1  # Total rows, and other-than-Back
+    HEADER_HEIGHT = 24  # Title bar height
+    STATUS_Y = 260  # Y position of status area
+    MLINE = 39  # Menu line height
+    LBLX = 45  # Menu item label X
+    MENU_CHR_W = 8
+    STAT_CHR_W = 10
+
+    dwin_abort_flag = False  # Flag to reset feedrate, return to Home
+
+    scroll_up = 2
+    scroll_down = 3
+
+    select_page = select_t()
+    select_file = select_t()
+    select_print = select_t()
+    select_prepare = select_t()
+
+    select_control = select_t()
+    select_axis = select_t()
+    select_temp = select_t()
+    select_motion = select_t()
+    select_tune = select_t()
+    select_PLA = select_t()
+    select_TPU = select_t()
+
+    index_file = MROWS
+    index_prepare = MROWS
+    index_control = MROWS
+    index_leveling = MROWS
+    index_tune = MROWS
+
+    MainMenu = 0
+    SelectFile = 1
+    Prepare = 2
+    Control = 3
+    Leveling = 4
+    PrintProcess = 5
+    AxisMove = 6
+    TemperatureID = 7
+    Motion = 8
+    Info = 9
+    Tune = 10
+    PLAPreheat = 11
+    TPUPreheat = 12
+    MaxSpeed = 13
+    MaxSpeed_value = 14
+    MaxAcceleration = 15
+    MaxAcceleration_value = 16
+    MaxJerk = 17
+    MaxJerk_value = 18
+    Step = 19
+    Step_value = 20
+    FeatureNotAvailable = 21
+
+    # Last Process ID
+    Last_Prepare = 21
+    last_status = ""
+
+    # Back Process ID
+    Back_Main = 22
+    Back_Print = 23
+
+    # Date variable ID
+    Move_X = 24
+    Move_Y = 25
+    Move_Z = 26
+    Extruder = 27
+    ETemp = 28
+    Homeoffset = 29
+    BedTemp = 30
+    FanSpeed = 31
+    PrintSpeed = 32
+
+    Print_window = 33
+    Popup_Window = 34
+
+    MINUNITMULT = 10
+
+    EncoderRateLimit = True
+
+    dwin_zoffset = 0.0
+    last_zoffset = 0.0
+
+    # Picture ID
+    Start_Process = 0
+
+    # IMAGE LIBRARIES ID
+    ICON = 0
+    GIF_ICON = 27
+    languages = {
+            "chinese": 2,
+            "english": 4,
+            "german": 6,
+            "russian": 9,
+            "french": 12,
+            "turkish": 15, 
+            "spanish": 17,
+            "italian": 19,
+            "portuguese": 21,
+            "japanese": 23, 
+            "korean": 25
+        }
+
+    # ICON ID
+    icon_logo = 0
+    icon_print = 1
+    icon_print_selected = 2
+    icon_prepare = 3
+    icon_prepare_selected = 4
+    icon_control = 5
+    icon_control_selected = 6
+    icon_leveling = 7
+    icon_leveling_selected = 8
+    icon_hotend_temp = 9
+    icon_bedtemp = 10
+    icon_speed = 11
+    icon_z_offset = 12
+    icon_back = 13
+    icon_file = 14
+    icon_print_time = 15
+    icon_remain_time = 16
+    icon_tune = 17
+    icon_tune_selected = 18
+    icon_pause = 19
+    icon_pause_selected = 20
+    icon_continue = 21
+    icon_continue_selected = 22
+    icon_stop = 23
+    icon_stop_selected = 24
+    icon_bar = 25
+    icon_more = 26
+
+    icon_axis = 27
+    icon_close_motor = 28
+    icon_homing = 29
+    icon_set_home = 30
+    icon_preheat_pla = 31
+    icon_preheat_tpu = 32
+    icon_cool = 33
+    icon_language = 34
+
+    icon_move_x = 35
+    icon_move_y = 36
+    icon_move_z = 37
+    icon_move_e = 38
+
+    icon_temperature = 40
+    icon_motion = 41
+    icon_write_eeprom = 42
+    icon_read_eeprom = 43
+    icon_resume_eeprom = 44
+    icon_info = 45
+
+    icon_SetEndTemp = 46
+    icon_SetBedTemp = 47
+    icon_FanSpeed = 48
+    icon_SetPLAPreheat = 49
+    icon_SetTPUPreheat = 50
+
+    icon_MaxSpeed = 51
+    icon_MaxAccelerated = 52
+    icon_MaxJerk = 53
+    icon_Step = 54
+    icon_PrintSize = 55
+    icon_Version = 56
+    icon_Contact = 57
+    icon_StockConfiguraton = 58
+    icon_MaxSpeedX = 59
+    icon_MaxSpeedY = 60
+    icon_MaxSpeedZ = 61
+    icon_MaxSpeedE = 62
+    icon_MaxAccX = 63
+    icon_MaxAccY = 64
+    icon_MaxAccZ = 65
+    icon_MaxAccE = 66
+    icon_MaxSpeedJerkX = 67
+    icon_MaxSpeedJerkY = 68
+    icon_MaxSpeedJerkZ = 69
+    icon_MaxSpeedJerkE = 70
+    icon_StepX = 71
+    icon_StepY = 72
+    icon_StepZ = 73
+    icon_StepE = 74
+    icon_Setspeed = 75
+    icon_SetZOffset = 76
+    icon_Rectangle = 77
+    icon_BLTouch = 78
+    icon_TempTooLow = 79
+    icon_AutoLeveling = 80
+    icon_TempTooHigh = 81
+    icon_NoTips_C = 82
+    icon_NoTips_E = 83
+    icon_continue_button = 96
+    icon_continue_button_hovered = 96
+    icon_cancel_button = 72
+    icon_cancel_button_hovered = 72
+    icon_confirm_button = 73
+    icon_confim_button_hovered = 73
+    icon_Info_0 = 90
+    icon_Info_1 = 91
+
+    icon_progress_0 = 145
+
+    # TEXT ICON ID
+    icon_TEXT_header_main = 1
+    icon_TEXT_header_printing = 20
+    icon_TEXT_header_tune = 17
+    icon_TEXT_header_file_selection = 26
+    icon_TEXT_header_motion = 33
+    icon_TEXT_header_move = 39
+    icon_TEXT_header_prepare = 40
+    icon_TEXT_header_pause = 27
+    icon_TEXT_header_temperature = 49
+    icon_TEXT_header_control = 80
+    icon_TEXT_header_print_finish = 81
+    icon_TEXT_header_leveling = 85
+    icon_TEXT_header_max_speed = 88
+    icon_TEXT_header_language_selection = 106
+    icon_TEXT_header_info = 61
+    icon_TEXT_header_PLA_settings = 62
+    icon_TEXT_header_TPU_settings = 64
+
+    icon_popup_nozzle_temp_too_high = 71
+    icon_popup_nozzle_temp_too_low = 69
+    icon_popup_bed_temp_too_low = 140
+    icon_popup_bed_temp_too_high = 141
+    icon_popup_unexpected_stoppage = 70
+    icon_popup_filament_reloaded = 67
+    icon_popup_filament_runout = 68
+    icon_popup_pause_print = 76
+    icon_popup_stop_print = 77
+    icon_popup_homing = 84
+
+    icon_TEXT_Print = 2
+    icon_TEXT_Print_selected = 8
+    icon_TEXT_Prepare = 3
+    icon_TEXT_Prepare_selected = 9
+    icon_TEXT_Control = 4
+    icon_TEXT_Control_selected = 10
+    icon_TEXT_Leveling = 14
+    icon_TEXT_Leveling_selected = 15
+    icon_TEXT_Info = 5
+    icon_TEXT_Info_selected = 11
+    icon_TEXT_Stop = 6
+    icon_TEXT_Stop_selected = 12
+    icon_TEXT_Pause = 7
+    icon_TEXT_Pause_selected = 13
+    icon_TEXT_Z_Offset = 16
+    icon_TEXT_Tune = 78
+    icon_TEXT_Tune_selected = 79
+    icon_TEXT_Printing_Speed = 19
+    icon_TEXT_continue = 96
+    icon_TEXT_nozzle_temperature = 23
+    icon_TEXT_fan_speed = 22
+    icon_TEXT_back = 21
+    icon_TEXT_bed_temperature = 24
+    icon_TEXT_remain = 25
+    icon_TEXT_store_configuration = 28
+    icon_TEXT_read_configuration = 29
+    icon_TEXT_reset_configuration = 30
+    icon_TEXT_temperature = 31
+    icon_TEXT_motion = 32
+    # icon_TEXT_ =33
+    icon_TEXT_preheat_tpu = 34
+    icon_TEXT_preheat_pla = 35
+    icon_TEXT_auto_home = 36
+    icon_TEXT_Info = 37
+    icon_TEXT_disable_stepper = 38
+    icon_TEXT_cooldown = 41
+    icon_TEXT_move_x = 42
+    icon_TEXT_move_y = 43
+    icon_TEXT_move_z = 44
+    icon_TEXT_move_e = 45
+    icon_TEXT_move_axis = 46
+    icon_TEXT_preheat_pla_settings = 47
+    icon_TEXT_preheat_tpu_settings = 48
+    icon_TEXT_steps_per_mm = 54
+    icon_TEXT_max_acceleration = 55
+    icon_TEXT_max_corner = 56
+    icon_TEXT_max_speed = 57
+    icon_TEXT_save_pla_parameters = 63
+    icon_TEXT_save_tpu_parameters = 65
+    icon_TEXT_language_selection = 66
+    icon_TEXT_pla_fan_speed = 100
+    icon_TEXT_pla_nozzle_temperature = 101
+    icon_TEXT_pla_bed_temperature = 102
+    icon_TEXT_tpu_nozzle_temperature = 103
+    icon_TEXT_tpu_bed_temperature = 104
+    icon_TEXT_tpu_fan_speed = 105
+    icon_TEXT_max_speed_x = 107
+    icon_TEXT_max_speed_y = 108
+    icon_TEXT_max_speed_z = 109
+    icon_TEXT_max_speed_e = 110
+    icon_TEXT_max_acceleration_x = 112
+    icon_TEXT_max_acceleration_y = 113
+    icon_TEXT_max_acceleration_z = 114
+    icon_TEXT_max_acceleration_e = 115
+    icon_TEXT_hardware_version = 156
+    icon_TEXT_bed_size = 59
+    icon_TEXT_contact = 60
+
+    icon_text_printing_time = 18
+    icon_text_remain_time = 25
+
+    # Color Palette
+    color_white = 0xFFFF
+    color_yellow = 0xFF0F
+    color_popup_background = 0x31E8  # Popup background color
+    color_background_grey = 0x1145  # Dark grey background color
+    color_background_black = 0x0841  # Black background color
+    color_background_red = 0xF00F  # Red background color
+    color_popup_text = 0xD6BA  # Popup font_ background color
+    color_line = 0x3A6A  # Split line color
+    Rectangle_color = 0xEE2F  # Blue square cursor color
+    Percent_color = 0xFE29  # Percentage color
+    BarFill_color = 0x10E4  # Fill color of progress bar
+    Selected_color = 0x33BB  # Selected color
+
+    MENU_CHAR_LIMIT = 24
+
+    MOTION_CASE_RATE = 1
+    MOTION_CASE_ACCEL = 2
+    MOTION_CASE_JERK = MOTION_CASE_ACCEL + 0
+    MOTION_CASE_STEPS = MOTION_CASE_JERK + 1
+    MOTION_CASE_TOTAL = MOTION_CASE_STEPS
+
+    PREPARE_CASE_MOVE = 1
+    PREPARE_CASE_DISA = 2
+    PREPARE_CASE_HOME = 3
+    PREPARE_CASE_ZOFF = PREPARE_CASE_HOME + 1
+    PREPARE_CASE_PLA = PREPARE_CASE_ZOFF + 1
+    PREPARE_CASE_TPU = PREPARE_CASE_PLA + 1
+    PREPARE_CASE_COOL = PREPARE_CASE_TPU + 1
+    PREPARE_CASE_LANG = PREPARE_CASE_COOL + 0
+    PREPARE_CASE_TOTAL = PREPARE_CASE_LANG
+
+    CONTROL_CASE_TEMP = 1
+    CONTROL_CASE_MOVE = 2
+    CONTROL_CASE_INFO = 3
+    CONTROL_CASE_TOTAL = 3
+
+    TUNE_CASE_SPEED = 1
+    TUNE_CASE_TEMP = TUNE_CASE_SPEED + 1
+    TUNE_CASE_BED = TUNE_CASE_TEMP + 1
+    TUNE_CASE_FAN = TUNE_CASE_BED + 0
+    TUNE_CASE_ZOFF = TUNE_CASE_FAN + 1
+    TUNE_CASE_TOTAL = TUNE_CASE_ZOFF
+
+    TEMP_CASE_TEMP = 0 + 1
+    TEMP_CASE_BED = TEMP_CASE_TEMP + 1
+    TEMP_CASE_FAN = TEMP_CASE_BED + 0
+    TEMP_CASE_PLA = TEMP_CASE_FAN + 1
+    TEMP_CASE_TPU = TEMP_CASE_PLA + 1
+    TEMP_CASE_TOTAL = TEMP_CASE_TPU
+
+    PREHEAT_CASE_TEMP = 0 + 1
+    PREHEAT_CASE_BED = PREHEAT_CASE_TEMP + 1
+    PREHEAT_CASE_FAN = PREHEAT_CASE_BED + 0
+    PREHEAT_CASE_SAVE = PREHEAT_CASE_FAN + 1
+    PREHEAT_CASE_TOTAL = PREHEAT_CASE_SAVE
+
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.config = config
+        self.mutex = self.printer.get_reactor().mutex()
+        self.name = config.get_name()
+        self.reactor = self.printer.get_reactor()
+        self._logging = config.getboolean("logging", False)
+        self.gcode = self.printer.lookup_object("gcode")
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.encoder_state = self.ENCODER_DIFF_NO
+        language = config.get("language", "english")
+        self.selected_language = self.languages[language]
+
+
+        # register for key events
+        E3V3SEMenuKeys(config, self.key_event)
+
+        self.serial_bridge = E3V3SEPrinterSerialBridge(self.config)
+   
+       
+        #bridge = config.get('serial_bridge')
+
+        #self.serial_bridge = self.printer.lookup_object(
+        #    'serial_bridge %s' %(bridge))
+        self.serial_bridge.register_callback(
+            self._handle_serial_bridge_response)
+        
+        self.lcd = TJC3224_LCD(self.serial_bridge)
+        self.checkkey = self.MainMenu
+        self.pd = PrinterData(config)
+
+        self._update_interval = 1
+        self._update_timer = self.reactor.register_timer(self.EachMomentUpdate)
+
+
+
+    def key_event(self, key, eventtime):
+        if key == 'click':
+            self.encoder_state = self.ENCODER_DIFF_ENTER
+        elif key == 'long_click':
+            self.encoder_state = self.ENCODER_DIFF_ENTER
+        elif key == 'up':
+            self.encoder_state = self.ENCODER_DIFF_CCW
+        elif key == 'down':
+            self.encoder_state = self.ENCODER_DIFF_CW
+        self.encoder_has_data()
+
+    def get_encoder_state(self):
+        last_state = self.encoder_state
+        self.encoder_state = self.ENCODER_DIFF_NO
+        return  last_state
+    
+    def _handle_serial_bridge_response(self, data):
+        byte_debug = ' '.join(['0x{:02x}'.format(byte) for byte in data])
+        self.log("Received message: " + byte_debug)
+    
+    def send_text(self, text):
+        self.serial_bridge.send_text(text)
+
+    def _screen_update(self, eventtime):
+        self.pd.update_variable()
+        return eventtime + self._update_interval
+
+    def _screen_init(self, eventtime):
+        self.reactor.update_timer(
+            self._update_timer, eventtime + self._update_interval)
+        return self.reactor.NEVER
+
+    def handle_ready(self):
+        self.reactor.register_timer(
+            self._reset_screen, self.reactor.monotonic())
+         
+    def _reset_screen(self, eventtime):
+        self.log("Reset")
+        self.reactor.register_timer(
+            self._screen_init, self.reactor.monotonic() + 2.)
+        return self.reactor.NEVER
+
+    
+    def lcdExit(self):
+        logging.info("Shutting down the LCD")
+        self.lcd.set_backlight_brightness(0)
+
+    def MBASE(self, L):
+        return 45 + self.MLINE * L
+
+    def HMI_StartFrame(self, with_update):
+        self.Clear_Screen()
+        self.last_status = self.pd.status
+        if self.pd.status == "printing":
+            self.Goto_PrintProcess()
+            self.Draw_Status_Area(with_update)
+        elif self.pd.status in ["operational", "complete", "standby", "cancelled"]:
+            self.Goto_MainMenu()
+        else:
+            self.Goto_MainMenu()
+
+    def HMI_MainMenu(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_page.inc(4):
+                if self.select_page.now == 0:
+                    self.icon_Print()
+                if self.select_page.now == 1:
+                    self.icon_Print()
+                    self.icon_Prepare()
+                if self.select_page.now == 2:
+                    self.icon_Prepare()
+                    self.icon_Control()
+                if self.select_page.now == 3:
+                    self.icon_Control()
+                    if self.pd.HAS_ONESTEP_LEVELING:
+                        self.icon_Leveling(True)
+                    else:
+                        self.icon_StartInfo(True)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_page.dec():
+                if self.select_page.now == 0:
+                    self.icon_Print()
+                    self.icon_Prepare()
+                elif self.select_page.now == 1:
+                    self.icon_Prepare()
+                    self.icon_Control()
+                elif self.select_page.now == 2:
+                    self.icon_Control()
+                    if self.pd.HAS_ONESTEP_LEVELING:
+                        self.icon_Leveling(False)
+                    else:
+                        self.icon_StartInfo(False)
+                elif self.select_page.now == 3:
+                    if self.pd.HAS_ONESTEP_LEVELING:
+                        self.icon_Leveling(True)
+                    else:
+                        self.icon_StartInfo(True)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_page.now == 0:  # Print File
+                self.checkkey = self.SelectFile
+                self.Draw_Print_File_Menu()
+            if self.select_page.now == 1:  # Prepare
+                self.checkkey = self.Prepare
+                self.select_prepare.reset()
+                self.index_prepare = self.MROWS
+                self.Draw_Prepare_Menu()
+            if self.select_page.now == 2:  # Control
+                self.checkkey = self.Control
+                self.select_control.reset()
+                self.index_control = self.MROWS
+                self.Draw_Control_Menu()
+            if self.select_page.now == 3:  # Leveling or Info
+                if self.pd.HAS_ONESTEP_LEVELING:
+                    # The leveling menu is not implemented yet, therefore it popups
+                    # a "feature not available" window
+                    self.popup_caller = self.MainMenu
+                    self.checkkey = self.FeatureNotAvailable
+                    self.Draw_FeatureNotAvailable_Popup()
+
+                else:
+                    self.checkkey = self.Info
+                    self.Draw_Info_Menu()
+
+    def HMI_SelectFile(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        fullCnt = len(self.pd.GetFiles(refresh=True))
+
+        if encoder_state == self.ENCODER_DIFF_CW and fullCnt:
+            if self.select_file.inc(1 + fullCnt):
+                itemnum = self.select_file.now - 1  # -1 for "Back"
+                if (
+                    self.select_file.now > self.MROWS
+                    and self.select_file.now > self.index_file
+                ):  # Cursor past the bottom
+                    self.index_file = self.select_file.now  # New bottom line
+                    self.Scroll_Menu(self.scroll_up)
+                    self.Draw_SDItem(
+                        itemnum, self.MROWS
+                    )  # Draw and init the shift name
+                else:
+                    self.Move_Highlight(
+                        1, self.select_file.now + self.MROWS - self.index_file
+                    )  # Just move highlight
+        elif encoder_state == self.ENCODER_DIFF_CCW and fullCnt:
+            if self.select_file.dec():
+                itemnum = self.select_file.now - 1  # -1 for "Back"
+                if (
+                    self.select_file.now < self.index_file - self.MROWS
+                ):  # Cursor past the top
+                    self.index_file -= 1  # New bottom line
+                    self.Scroll_Menu(self.scroll_down)
+                    if self.index_file == self.MROWS:
+                        self.Draw_Back_First()
+                    else:
+                        self.Draw_SDItem(
+                            itemnum, 0
+                        )  # Draw the item (and init shift name)
+                else:
+                    self.Move_Highlight(
+                        -1, self.select_file.now + self.MROWS - self.index_file
+                    )  # Just move highlight
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_file.now == 0:  # Back
+                self.select_page.set(0)
+                self.Goto_MainMenu()
+            else:
+                filenum = self.select_file.now - 1
+                # Reset highlight for next entry
+                self.select_print.reset()
+                self.select_file.reset()
+
+                # // Start choice and print SD file
+                self.pd.HMI_flag.heat_flag = True
+                self.pd.HMI_flag.print_finish = False
+                self.pd.HMI_ValueStruct.show_mode = 0
+
+                self.pd.openAndPrintFile(filenum)
+                self.Goto_PrintProcess()
+
+    def HMI_Prepare(self):
+        """
+        This function handles the logic for scrolling through the prepare menu options,
+        selecting different actions, and executing the corresponding actions based on user input.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_prepare.inc(1 + self.PREPARE_CASE_TOTAL):
+                if (
+                    self.select_prepare.now > self.MROWS
+                    and self.select_prepare.now > self.index_prepare
+                ):
+                    self.index_prepare = self.select_prepare.now
+
+                    # Scroll up and draw a blank bottom line
+                    self.Scroll_Menu(self.scroll_up)
+                    self.Draw_Menu_Icon(
+                        self.MROWS, self.icon_axis + self.select_prepare.now - 1
+                    )
+
+                    # Draw "More" icon for sub-menus
+                    if self.index_prepare < 7:
+                        self.Draw_More_Icon(self.MROWS - self.index_prepare + 1)
+
+                    if self.pd.HAS_HOTEND:
+                        if self.index_prepare == self.PREPARE_CASE_TPU:
+                            self.Item_Prepare_TPU(self.MROWS)
+                    if self.pd.HAS_PREHEAT:
+                        if self.index_prepare == self.PREPARE_CASE_COOL:
+                            self.Item_Prepare_Cool(self.MROWS)
+                else:
+                    self.Move_Highlight(
+                        1, self.select_prepare.now + self.MROWS - self.index_prepare
+                    )
+
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_prepare.dec():
+                if self.select_prepare.now < self.index_prepare - self.MROWS:
+                    self.index_prepare -= 1
+                    self.Scroll_Menu(self.scroll_down)
+
+                    if self.index_prepare == self.MROWS:
+                        self.Draw_Back_First()
+                    else:
+                        self.Draw_Menu_Line(
+                            0, self.icon_axis + self.select_prepare.now - 1
+                        )
+
+                    if self.index_prepare < 7:
+                        self.Draw_More_Icon(self.MROWS - self.index_prepare + 1)
+
+                    if self.index_prepare == 6:
+                        self.Item_Prepare_Move(0)
+                    elif self.index_prepare == 7:
+                        self.Item_Prepare_Disable(0)
+                    elif self.index_prepare == 8:
+                        self.Item_Prepare_Home(0)
+                else:
+                    self.Move_Highlight(
+                        -1, self.select_prepare.now + self.MROWS - self.index_prepare
+                    )
+
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_prepare.now == 0:  # Back
+                self.select_page.set(1)
+                self.Goto_MainMenu()
+
+            elif self.select_prepare.now == self.PREPARE_CASE_MOVE:  # Axis move
+                self.checkkey = self.AxisMove
+                self.select_axis.reset()
+                self.Draw_Move_Menu()
+                self.pd.sendGCode("G92 E0")
+                self.pd.current_position.e = self.pd.HMI_ValueStruct.Move_E_scale = 0
+            elif self.select_prepare.now == self.PREPARE_CASE_DISA:  # Disable steppers
+                self.pd.sendGCode("M84")
+            elif self.select_prepare.now == self.PREPARE_CASE_HOME:  # Homing
+                self.checkkey = self.Last_Prepare
+                self.index_prepare = self.MROWS
+                self.pd.current_position.homing()
+                self.pd.HMI_flag.home_flag = True
+                self.Popup_Window_Home()
+                self.pd.sendGCode("G28")
+            elif self.select_prepare.now == self.PREPARE_CASE_ZOFF:  # Z-offset
+                self.checkkey = self.Homeoffset
+                if self.pd.HAS_BED_PROBE:
+                    self.pd.probe_calibrate()
+
+                self.pd.HMI_ValueStruct.show_mode = -4
+
+                self.lcd.draw_signed_float(
+                    True,
+                    self.lcd.font_8x8,
+                    self.color_white,
+                    self.color_background_black,
+                    2,
+                    3,
+                    175,
+                    self.MBASE(self.PREPARE_CASE_ZOFF + self.MROWS - self.index_prepare)
+                    - 10,
+                    self.pd.HMI_ValueStruct.offset_value,
+                )
+
+                self.EncoderRateLimit = False
+
+            elif self.select_prepare.now == self.PREPARE_CASE_PLA:  # PLA preheat
+                self.pd.preheat("PLA")
+
+            elif self.select_prepare.now == self.PREPARE_CASE_TPU:  # TPU preheat
+                self.pd.preheat("TPU")
+
+            elif self.select_prepare.now == self.PREPARE_CASE_COOL:  # Cool
+                if self.pd.HAS_FAN:
+                    self.pd.zero_fan_speeds()
+                self.pd.disable_all_heaters()
+
+            elif self.select_prepare.now == self.PREPARE_CASE_LANG:  # Toggle Language
+                self.HMI_ToggleLanguage()
+                self.Draw_Prepare_Menu()
+
+    def HMI_Control(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_control.inc(1 + self.CONTROL_CASE_TOTAL):
+                if (
+                    self.select_control.now > self.MROWS
+                    and self.select_control.now > self.index_control
+                ):
+                    self.index_control = self.select_control.now
+                    self.Scroll_Menu(self.scroll_up)
+                    self.Draw_Menu_Icon(
+                        self.MROWS, self.icon_temperature + self.index_control - 1
+                    )
+                    self.Draw_More_Icon(
+                        self.CONTROL_CASE_TEMP + self.MROWS - self.index_control
+                    )  # Temperature >
+                    self.Draw_More_Icon(
+                        self.CONTROL_CASE_MOVE + self.MROWS - self.index_control
+                    )  # Motion >
+                    if self.index_control > self.MROWS:
+                        self.Draw_More_Icon(
+                            self.CONTROL_CASE_INFO + self.MROWS - self.index_control
+                        )  # Info >
+                        self.lcd.move_screen_area(
+                            1,
+                            0,
+                            104,
+                            24,
+                            114,
+                            self.LBLX,
+                            self.MBASE(self.CONTROL_CASE_INFO - 1),
+                        )
+                else:
+                    self.Move_Highlight(
+                        1, self.select_control.now + self.MROWS - self.index_control
+                    )
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_control.dec():
+                if self.select_control.now < self.index_control - self.MROWS:
+                    self.index_control -= 1
+                    self.Scroll_Menu(self.scroll_down)
+                    if self.index_control == self.MROWS:
+                        self.Draw_Back_First()
+                    else:
+                        self.Draw_Menu_Line(
+                            0, self.icon_temperature + self.select_control.now - 1
+                        )
+                    self.Draw_More_Icon(
+                        0 + self.MROWS - self.index_control + 1
+                    )  # Temperature >
+                    self.Draw_More_Icon(
+                        1 + self.MROWS - self.index_control + 1
+                    )  # Motion >
+                else:
+                    self.Move_Highlight(
+                        -1, self.select_control.now + self.MROWS - self.index_control
+                    )
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_control.now == 0:  # Back
+                self.select_page.set(2)
+                self.Goto_MainMenu()
+            if self.select_control.now == self.CONTROL_CASE_TEMP:  # Temperature
+                self.checkkey = self.TemperatureID
+                self.pd.HMI_ValueStruct.show_mode = -1
+                self.select_temp.reset()
+                self.Draw_Temperature_Menu()
+            if self.select_control.now == self.CONTROL_CASE_MOVE:  # Motion
+                self.checkkey = self.Motion
+                self.select_motion.reset()
+                self.Draw_Motion_Menu()
+            if self.select_control.now == self.CONTROL_CASE_INFO:  # Info
+                self.checkkey = self.Info
+                self.Draw_Info_Menu()
+
+    def HMI_FeatureNotAvailable(self):
+        """
+        Handles the "feature not available" popup.
+        This method is called when the user enters a menu that
+        is not implemented yet in the display interface. After
+        the user presses the confirmation, he needs to go back to
+        where he came from.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_ENTER:
+            self.checkkey = self.popup_caller
+            if self.popup_caller == self.MainMenu:
+                self.Goto_MainMenu()
+            if self.popup_caller == self.Motion:
+                self.Draw_Motion_Menu()
+
+    def HMI_Info(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.pd.HAS_ONESTEP_LEVELING:
+                self.checkkey = self.Control
+                self.select_control.set(self.CONTROL_CASE_INFO)
+                self.Draw_Control_Menu()
+            else:
+                self.select_page.set(3)
+                self.Goto_MainMenu()
+
+    def HMI_Printing(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if self.pd.HMI_flag.done_confirm_flag:
+            if encoder_state == self.ENCODER_DIFF_ENTER:
+                self.pd.HMI_flag.done_confirm_flag = False
+                self.dwin_abort_flag = True  # Reset feedrate, return to Home
+            return
+
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_print.inc(3):
+                if self.select_print.now == 0:
+                    self.show_tune()
+                elif self.select_print.now == 1:
+                    self.show_tune()
+                    if self.pd.printingIsPaused():
+                        self.show_continue()
+                    else:
+                        self.show_pause()
+                elif self.select_print.now == 2:
+                    if self.pd.printingIsPaused():
+                        self.show_continue()
+                    else:
+                        self.show_pause()
+                    self.show_stop()
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_print.dec():
+                if self.select_print.now == 0:
+                    self.show_tune()
+                    if self.pd.printingIsPaused():
+                        self.show_continue()
+                    else:
+                        self.show_pause()
+                elif self.select_print.now == 1:
+                    if self.pd.printingIsPaused():
+                        self.show_continue()
+                    else:
+                        self.show_pause()
+                    self.show_stop()
+                elif self.select_print.now == 2:
+                    self.show_stop()
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_print.now == 0:  # Tune
+                self.checkkey = self.Tune
+                self.pd.HMI_ValueStruct.show_mode = 0
+                self.select_tune.reset()
+                self.index_tune = self.MROWS
+                self.Draw_Tune_Menu()
+            elif self.select_print.now == 1:  # Pause
+                if self.pd.HMI_flag.pause_flag:
+                    self.show_pause()
+                    self.pd.resume_job()
+                else:
+                    self.pd.HMI_flag.select_flag = True
+                    self.checkkey = self.Print_window
+                    self.Popup_window_PauseOrStop()
+            elif self.select_print.now == 2:  # Stop
+                self.pd.HMI_flag.select_flag = True
+                self.checkkey = self.Print_window
+                self.Popup_window_PauseOrStop()
+
+    # Pause and Stop window */
+    def HMI_PauseOrStop(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_CW:
+            self.Draw_Select_Highlight(False)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.Draw_Select_Highlight(True)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_print.now == 1:  # pause window
+                if self.pd.HMI_flag.select_flag:
+                    self.pd.HMI_flag.pause_action = True
+                    self.show_continue()
+                    self.pd.pause_job()
+                self.Goto_PrintProcess()
+            elif self.select_print.now == 2:  # stop window
+                if self.pd.HMI_flag.select_flag:
+                    self.dwin_abort_flag = True  # Reset feedrate, return to Home
+                    self.pd.cancel_job()
+                    self.Goto_MainMenu()
+                else:
+                    self.Goto_PrintProcess()  # cancel stop
+
+    # Tune  */
+    def HMI_Tune(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_tune.inc(1 + self.TUNE_CASE_TOTAL):
+                if (
+                    self.select_tune.now > self.MROWS
+                    and self.select_tune.now > self.index_tune
+                ):
+                    self.index_tune = self.select_tune.now
+                    self.Scroll_Menu(self.scroll_up)
+                else:
+                    self.Move_Highlight(
+                        1, self.select_tune.now + self.MROWS - self.index_tune
+                    )
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_tune.dec():
+                if self.select_tune.now < self.index_tune - self.MROWS:
+                    self.index_tune -= 1
+                    self.Scroll_Menu(self.scroll_down)
+                    if self.index_tune == self.MROWS:
+                        self.Draw_Back_First()
+                else:
+                    self.Move_Highlight(
+                        -1, self.select_tune.now + self.MROWS - self.index_tune
+                    )
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_tune.now == 0:  # Back
+                self.select_print.set(0)
+                self.Goto_PrintProcess()
+            elif self.select_tune.now == self.TUNE_CASE_SPEED:  # Print speed
+                self.checkkey = self.PrintSpeed
+                self.pd.HMI_ValueStruct.print_speed = self.pd.feedrate_percentage
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_white,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.TUNE_CASE_SPEED + self.MROWS - self.index_tune) - 8,
+                    self.pd.feedrate_percentage,
+                )
+                self.EncoderRateLimit = False
+            elif self.select_tune.now == self.TUNE_CASE_ZOFF:  # z offset
+                self.checkkey = self.Homeoffset
+                self.lcd.draw_signed_float(
+                    True,
+                    self.lcd.font_8x8,
+                    self.color_white,
+                    self.color_background_black,
+                    2,
+                    3,
+                    175,
+                    self.MBASE(self.TUNE_CASE_ZOFF) - 10,
+                    self.pd.HMI_ValueStruct.offset_value,
+                )
+
+    def HMI_PrintSpeed(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.print_speed += 1
+
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.print_speed -= 1
+
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            self.checkkey = self.Tune
+            self.encoderRate = True
+            self.pd.set_feedrate(self.pd.HMI_ValueStruct.print_speed)
+
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            200,
+            self.MBASE(self.select_tune.now + self.MROWS - self.index_tune) - 8,
+            self.pd.HMI_ValueStruct.print_speed,
+        )
+
+    def HMI_AxisMove(self):
+        """
+        Handles the axis movement in the HMI (Human Machine Interface).
+
+        This function checks the encoder state and performs the corresponding action based on the state.
+        It updates the display and handles the movement of the X, Y, Z axes, and the extruder.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        # In case of "nozzle too cold" popup is on the screen
+        if self.pd.PREVENT_COLD_EXTRUSION:
+            if self.pd.HMI_flag.ETempTooLow_flag:
+                # Resuming after "nozzle too cold" popup should clear the flag and draw move menu again
+                if encoder_state == self.ENCODER_DIFF_ENTER:
+                    self.pd.HMI_flag.ETempTooLow_flag = False
+                    self.pd.current_position.e = (
+                        self.pd.HMI_ValueStruct.Move_E_scale
+                    ) = 0
+                    self.Draw_Move_Menu()
+                return
+
+        # Avoid flicker by updating only the previous menu
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_axis.inc(1 + 4):
+                self.Move_Highlight(1, self.select_axis.now)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_axis.dec():
+                self.Move_Highlight(-1, self.select_axis.now)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            selected_line = self.select_axis.now
+            if selected_line == 0:  # Back
+                self.checkkey = self.Prepare
+                self.select_prepare.set(1)
+                self.index_prepare = self.MROWS
+                self.Draw_Prepare_Menu()
+            elif selected_line == 1:  # X axis move
+                self.checkkey = self.Move_X
+                self.pd.HMI_ValueStruct.Move_X_scale = (
+                    self.pd.current_position.x * self.MINUNITMULT
+                )
+                self.lcd.draw_float_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    1,
+                    175,
+                    self.MBASE(selected_line) - 10,
+                    self.pd.HMI_ValueStruct.Move_X_scale,
+                )
+                self.EncoderRateLimit = False
+            elif selected_line == 2:  # Y axis move
+                self.checkkey = self.Move_Y
+                self.pd.HMI_ValueStruct.Move_Y_scale = (
+                    self.pd.current_position.y * self.MINUNITMULT
+                )
+                self.lcd.draw_float_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    1,
+                    175,
+                    self.MBASE(selected_line) - 10,
+                    self.pd.HMI_ValueStruct.Move_Y_scale,
+                )
+                self.EncoderRateLimit = False
+            elif selected_line == 3:  # Z axis move
+                self.checkkey = self.Move_Z
+                self.pd.HMI_ValueStruct.Move_Z_scale = (
+                    self.pd.current_position.z * self.MINUNITMULT
+                )
+                self.lcd.draw_float_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    1,
+                    175,
+                    self.MBASE(selected_line) - 10,
+                    self.pd.HMI_ValueStruct.Move_Z_scale,
+                )
+                self.EncoderRateLimit = False
+            elif selected_line == 4:  # Extruder
+                # Check if nozzle is too cold and don't allow extrusion. Popup warning instead
+                if self.pd.PREVENT_COLD_EXTRUSION:
+                    if (
+                        self.pd.thermalManager["temp_hotend"][0]["celsius"]
+                        < self.pd.EXTRUDE_MINTEMP
+                    ):
+                        self.pd.HMI_flag.ETempTooLow_flag = True
+                        self.Popup_Window_ETempTooLow()
+                        return
+                self.checkkey = self.Extruder
+                self.pd.HMI_ValueStruct.Move_E_scale = (
+                    self.pd.current_position.e * self.MINUNITMULT
+                )
+                self.lcd.draw_signed_float(
+                    False,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    1,
+                    175,
+                    self.MBASE(selected_line) - 10,
+                    self.pd.HMI_ValueStruct.Move_E_scale,
+                )
+                self.EncoderRateLimit = False
+
+    def HMI_Move_X(self):
+        """
+        Handles the X axis move logic based on the encoder input.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            # Enable change in Move X value, draw text as yellow
+            self.checkkey = self.AxisMove
+            self.EncoderRateLimit = True
+            self.lcd.draw_float_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_yellow,
+                self.color_background_black,
+                3,
+                1,
+                175,
+                self.MBASE(1) - 10,
+                self.pd.HMI_ValueStruct.Move_X_scale,
+            )
+            self.pd.moveAbsolute("X", self.pd.current_position.x, 5000)
+
+            return
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.Move_X_scale += 1
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.Move_X_scale -= 1
+
+        if (
+            self.pd.HMI_ValueStruct.Move_X_scale
+            < (self.pd.X_MIN_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_X_scale = (
+                self.pd.X_MIN_POS
+            ) * self.MINUNITMULT
+
+        if (
+            self.pd.HMI_ValueStruct.Move_X_scale
+            > (self.pd.X_MAX_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_X_scale = (
+                self.pd.X_MAX_POS
+            ) * self.MINUNITMULT
+
+        self.pd.current_position.x = self.pd.HMI_ValueStruct.Move_X_scale / 10
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(1) - 10,
+            self.pd.HMI_ValueStruct.Move_X_scale,
+        )
+
+    def HMI_Move_Y(self):
+        """
+        Handles the Y axis move logic based on the encoder input.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            self.checkkey = self.AxisMove
+            self.EncoderRateLimit = True
+            self.lcd.draw_float_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_yellow,
+                self.color_background_black,
+                3,
+                1,
+                175,
+                self.MBASE(2) - 10,
+                self.pd.HMI_ValueStruct.Move_Y_scale,
+            )
+
+            self.pd.moveAbsolute("Y", self.pd.current_position.y, 5000)
+
+            return
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.Move_Y_scale += 1
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.Move_Y_scale -= 1
+
+        if (
+            self.pd.HMI_ValueStruct.Move_Y_scale
+            < (self.pd.Y_MIN_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_Y_scale = (
+                self.pd.Y_MIN_POS
+            ) * self.MINUNITMULT
+
+        if (
+            self.pd.HMI_ValueStruct.Move_Y_scale
+            > (self.pd.Y_MAX_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_Y_scale = (
+                self.pd.Y_MAX_POS
+            ) * self.MINUNITMULT
+
+        self.pd.current_position.y = self.pd.HMI_ValueStruct.Move_Y_scale / 10
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(2) - 10,
+            self.pd.HMI_ValueStruct.Move_Y_scale,
+        )
+
+    def HMI_Move_Z(self):
+        """
+        Handles the Z axis move logic based on the encoder input.
+        """
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            self.checkkey = self.AxisMove
+            self.EncoderRateLimit = True
+            self.lcd.draw_float_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_yellow,
+                self.color_background_black,
+                3,
+                1,
+                175,
+                self.MBASE(3) - 10,
+                self.pd.HMI_ValueStruct.Move_Z_scale,
+            )
+            self.pd.moveAbsolute("Z", self.pd.current_position.z, 600)
+
+            return
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.Move_Z_scale += 1
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.Move_Z_scale -= 1
+
+        if (
+            self.pd.HMI_ValueStruct.Move_Z_scale
+            < (self.pd.Z_MIN_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_Z_scale = (
+                self.pd.Z_MIN_POS
+            ) * self.MINUNITMULT
+
+        if (
+            self.pd.HMI_ValueStruct.Move_Z_scale
+            > (self.pd.Z_MAX_POS) * self.MINUNITMULT
+        ):
+            self.pd.HMI_ValueStruct.Move_Z_scale = (
+                self.pd.Z_MAX_POS
+            ) * self.MINUNITMULT
+
+        self.pd.current_position.z = self.pd.HMI_ValueStruct.Move_Z_scale / 10
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(3) - 10,
+            self.pd.HMI_ValueStruct.Move_Z_scale,
+        )
+
+    def HMI_Move_E(self):
+        """
+        Handles the Extruder move logic based on the encoder input.
+        """
+        self.pd.last_E_scale = 0
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            self.checkkey = self.AxisMove
+            self.EncoderRateLimit = True
+            self.pd.last_E_scale = self.pd.HMI_ValueStruct.Move_E_scale
+            self.lcd.draw_signed_float(
+                True,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                1,
+                175,
+                self.MBASE(4) - 10,
+                self.pd.HMI_ValueStruct.Move_E_scale,
+            )
+            self.pd.moveAbsolute("E", self.pd.current_position.e, 300)
+
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.Move_E_scale += 1
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.Move_E_scale -= 1
+
+        if (self.pd.HMI_ValueStruct.Move_E_scale - self.pd.last_E_scale) > (
+            self.pd.EXTRUDE_MAXLENGTH
+        ) * self.MINUNITMULT:
+            self.pd.HMI_ValueStruct.Move_E_scale = (
+                self.pd.last_E_scale + (self.pd.EXTRUDE_MAXLENGTH) * self.MINUNITMULT
+            )
+        elif (self.pd.last_E_scale - self.pd.HMI_ValueStruct.Move_E_scale) > (
+            self.pd.EXTRUDE_MAXLENGTH
+        ) * self.MINUNITMULT:
+            self.pd.HMI_ValueStruct.Move_E_scale = (
+                self.pd.last_E_scale - (self.pd.EXTRUDE_MAXLENGTH) * self.MINUNITMULT
+            )
+        self.pd.current_position.e = self.pd.HMI_ValueStruct.Move_E_scale / 10
+        self.lcd.draw_signed_float(
+            True,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(4) - 10,
+            self.pd.HMI_ValueStruct.Move_E_scale,
+        )
+
+    def HMI_Temperature(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_temp.inc(1 + self.TEMP_CASE_TOTAL):
+                self.Move_Highlight(1, self.select_temp.now)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_temp.dec():
+                self.Move_Highlight(-1, self.select_temp.now)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_temp.now == 0:  # back
+                self.checkkey = self.Control
+                self.select_control.set(1)
+                self.index_control = self.MROWS
+                self.Draw_Control_Menu()
+            elif self.select_temp.now == self.TEMP_CASE_TEMP:  # Nozzle temperature
+                self.checkkey = self.ETemp
+                self.pd.HMI_ValueStruct.E_Temp = self.pd.thermalManager["temp_hotend"][
+                    0
+                ]["target"]
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(1) - 8,
+                    self.pd.thermalManager["temp_hotend"][0]["target"],
+                )
+                self.EncoderRateLimit = False
+            elif self.select_temp.now == self.TEMP_CASE_BED:  # Bed temperature
+                self.checkkey = self.BedTemp
+                self.pd.HMI_ValueStruct.Bed_Temp = self.pd.thermalManager["temp_bed"][
+                    "target"
+                ]
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(2) - 8,
+                    self.pd.thermalManager["temp_bed"]["target"],
+                )
+                self.EncoderRateLimit = False
+            elif self.select_temp.now == self.TEMP_CASE_FAN:  # Fan speed
+                self.checkkey = self.FanSpeed
+                self.pd.HMI_ValueStruct.Fan_speed = self.pd.thermalManager["fan_speed"][
+                    0
+                ]
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(3) - 8,
+                    self.pd.thermalManager["fan_speed"][0],
+                )
+                self.EncoderRateLimit = False
+
+            elif self.select_temp.now == self.TEMP_CASE_PLA:  # PLA preheat setting
+                self.checkkey = self.PLAPreheat
+                self.select_PLA.reset()
+                self.pd.HMI_ValueStruct.show_mode = -2
+
+                self.Clear_Main_Window()
+                self.lcd.draw_icon(
+                    False,
+                    self.selected_language,
+                    self.icon_TEXT_header_PLA_settings,
+                    self.HEADER_HEIGHT,
+                    1,
+                )
+
+                self.Draw_Back_First()
+                i = 1
+                self.Draw_Menu_Line_With_Only_Icons(
+                    i, self.icon_SetEndTemp, self.icon_TEXT_pla_nozzle_temperature
+                )  # PLA nozzle temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_white,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(i) - 8,
+                    self.pd.material_preset[0].hotend_temp,
+                )
+                if self.pd.HAS_HEATED_BED:
+                    i += 1
+                    self.Draw_Menu_Line_With_Only_Icons(
+                        i, self.icon_SetBedTemp, self.icon_TEXT_pla_bed_temperature
+                    )  # PLA bed temp
+                    self.lcd.draw_int_value(
+                        True,
+                        True,
+                        0,
+                        self.lcd.font_8x8,
+                        self.color_white,
+                        self.color_background_black,
+                        3,
+                        200,
+                        self.MBASE(i) - 8,
+                        self.pd.material_preset[0].bed_temp,
+                    )
+                if self.pd.HAS_FAN:
+                    i += 1
+                    self.Draw_Menu_Line_With_Only_Icons(
+                        i, self.icon_FanSpeed, self.icon_TEXT_pla_fan_speed
+                    )  # PLA fan speed
+                    self.lcd.draw_int_value(
+                        True,
+                        True,
+                        0,
+                        self.lcd.font_8x8,
+                        self.color_white,
+                        self.color_background_black,
+                        3,
+                        200,
+                        self.MBASE(i) - 8,
+                        self.pd.material_preset[0].fan_speed,
+                    )
+                i += 1
+                self.Draw_Menu_Line_With_Only_Icons(
+                    i, self.icon_write_eeprom, self.icon_TEXT_save_pla_parameters
+                )  # Save PLA configuration
+            elif self.select_temp.now == self.TEMP_CASE_TPU:  # TPU preheat setting
+                self.checkkey = self.TPUPreheat
+                self.select_TPU.reset()
+                self.pd.HMI_ValueStruct.show_mode = -3
+                self.Clear_Main_Window()
+                self.lcd.draw_icon(
+                    False,
+                    self.selected_language,
+                    self.icon_TEXT_header_TPU_settings,
+                    self.HEADER_HEIGHT,
+                    1,
+                )
+
+                self.Draw_Back_First()
+                i = 1
+                self.Draw_Menu_Line_With_Only_Icons(
+                    i, self.icon_SetEndTemp, self.icon_TEXT_tpu_nozzle_temperature
+                )  # TPU nozzle temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_white,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(i) - 8,
+                    self.pd.material_preset[1].hotend_temp,
+                )
+                if self.pd.HAS_HEATED_BED:
+                    i += 1
+                    self.Draw_Menu_Line_With_Only_Icons(
+                        i, self.icon_SetBedTemp, self.icon_TEXT_tpu_bed_temperature
+                    )  # TPU bed temp
+                    self.lcd.draw_int_value(
+                        True,
+                        True,
+                        0,
+                        self.lcd.font_8x8,
+                        self.color_white,
+                        self.color_background_black,
+                        3,
+                        200,
+                        self.MBASE(i) - 8,
+                        self.pd.material_preset[1].bed_temp,
+                    )
+                if self.pd.HAS_FAN:
+                    i += 1
+                    self.Draw_Menu_Line_With_Only_Icons(
+                        i, self.icon_FanSpeed, self.icon_TEXT_tpu_fan_speed
+                    )  # TPU fan speed
+                    self.lcd.draw_int_value(
+                        True,
+                        True,
+                        0,
+                        self.lcd.font_8x8,
+                        self.color_white,
+                        self.color_background_black,
+                        3,
+                        200,
+                        self.MBASE(i) - 8,
+                        self.pd.material_preset[1].fan_speed,
+                    )
+                i += 1
+                self.Draw_Menu_Line_With_Only_Icons(
+                    i, self.icon_write_eeprom, self.icon_TEXT_save_tpu_parameters
+                )  # Save TPU configuration
+
+    def HMI_PLAPreheatSetting(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        # Avoid flicker by updating only the previous menu
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_PLA.inc(1 + self.PREHEAT_CASE_TOTAL):
+                self.Move_Highlight(1, self.select_PLA.now)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_PLA.dec():
+                self.Move_Highlight(-1, self.select_PLA.now)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_PLA.now == 0:  # Back
+                self.checkkey = self.TemperatureID
+                self.select_temp.now = self.TEMP_CASE_PLA
+                self.pd.HMI_ValueStruct.show_mode = -1
+                self.Draw_Temperature_Menu()
+            elif self.select_PLA.now == self.PREHEAT_CASE_TEMP:  # Nozzle temperature
+                self.checkkey = self.ETemp
+                self.pd.HMI_ValueStruct.E_Temp = self.pd.material_preset[0].hotend_temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_TEMP) - 8,
+                    self.pd.material_preset[0].hotend_temp,
+                )
+                self.EncoderRateLimit = False
+            elif self.select_PLA.now == self.PREHEAT_CASE_BED:  # Bed temperature
+                self.checkkey = self.BedTemp
+                self.pd.HMI_ValueStruct.Bed_Temp = self.pd.material_preset[0].bed_temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_BED) - 8,
+                    self.pd.material_preset[0].bed_temp,
+                )
+                self.EncoderRateLimit = False
+            elif self.select_PLA.now == self.PREHEAT_CASE_FAN:  # Fan speed
+                self.checkkey = self.FanSpeed
+                self.pd.HMI_ValueStruct.Fan_speed = self.pd.material_preset[0].fan_speed
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_FAN) - 8,
+                    self.pd.material_preset[0].fan_speed,
+                )
+                self.EncoderRateLimit = False
+            elif (
+                self.select_PLA.now == self.PREHEAT_CASE_SAVE
+            ):  # Save PLA configuration
+                success = self.pd.save_settings()
+                self.HMI_AudioFeedback(success)
+
+    def HMI_TPUPreheatSetting(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        # Avoid flicker by updating only the previous menu
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_TPU.inc(1 + self.PREHEAT_CASE_TOTAL):
+                self.Move_Highlight(1, self.select_TPU.now)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_TPU.dec():
+                self.Move_Highlight(-1, self.select_TPU.now)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_TPU.now == 0:  # Back
+                self.checkkey = self.TemperatureID
+                self.select_temp.now = self.TEMP_CASE_TPU
+                self.pd.HMI_ValueStruct.show_mode = -1
+                self.Draw_Temperature_Menu()
+
+            elif self.select_TPU.now == self.PREHEAT_CASE_TEMP:  # Nozzle temperature
+                self.checkkey = self.ETemp
+                self.pd.HMI_ValueStruct.E_Temp = self.pd.material_preset[1].hotend_temp
+                print(self.pd.HMI_ValueStruct.E_Temp)
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_TEMP) - 8,
+                    self.pd.material_preset[1].hotend_temp,
+                )
+                self.EncoderRateLimit = False
+            elif self.select_TPU.now == self.PREHEAT_CASE_BED:  # Bed temperature
+                self.checkkey = self.BedTemp
+                self.pd.HMI_ValueStruct.Bed_Temp = self.pd.material_preset[1].bed_temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_BED) - 8,
+                    self.pd.material_preset[1].bed_temp,
+                )
+                self.EncoderRateLimit = False
+            elif self.select_TPU.now == self.PREHEAT_CASE_FAN:  # Fan speed
+                self.checkkey = self.FanSpeed
+                self.pd.HMI_ValueStruct.Fan_speed = self.pd.material_preset[1].fan_speed
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(self.PREHEAT_CASE_FAN) - 8,
+                    self.pd.material_preset[1].fan_speed,
+                )
+                self.EncoderRateLimit = False
+            elif (
+                self.select_TPU.now == self.PREHEAT_CASE_SAVE
+            ):  # Save PLA configuration
+                success = self.pd.save_settings()
+                self.HMI_AudioFeedback(success)
+
+    def HMI_ETemp(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if self.pd.HMI_ValueStruct.show_mode == -1:
+            temp_line = self.TEMP_CASE_TEMP
+        elif self.pd.HMI_ValueStruct.show_mode == -2:
+            temp_line = self.PREHEAT_CASE_TEMP
+        elif self.pd.HMI_ValueStruct.show_mode == -3:
+            temp_line = self.PREHEAT_CASE_TEMP
+        else:
+            temp_line = self.TUNE_CASE_TEMP + self.MROWS - self.index_tune
+
+        if encoder_state == self.ENCODER_DIFF_ENTER:
+            self.EncoderRateLimit = True
+            if self.pd.HMI_ValueStruct.show_mode == -1:  # temperature
+                self.checkkey = self.TemperatureID
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(temp_line) - 8,
+                    self.pd.HMI_ValueStruct.E_Temp,
+                )
+            elif self.pd.HMI_ValueStruct.show_mode == -2:
+                self.checkkey = self.PLAPreheat
+                self.pd.material_preset[0].hotend_temp = self.pd.HMI_ValueStruct.E_Temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(temp_line) - 8,
+                    self.pd.material_preset[0].hotend_temp,
+                )
+                return
+            elif self.pd.HMI_ValueStruct.show_mode == -3:
+                self.checkkey = self.TPUPreheat
+                self.pd.material_preset[1].hotend_temp = self.pd.HMI_ValueStruct.E_Temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(temp_line) - 8,
+                    self.pd.material_preset[1].hotend_temp,
+                )
+                return
+            else:  # tune
+                self.checkkey = self.Tune
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(temp_line) - 8,
+                    self.pd.HMI_ValueStruct.E_Temp,
+                )
+                self.pd.setTargetHotend(self.pd.HMI_ValueStruct.E_Temp, 0)
+            return
+
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.E_Temp += 1
+
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.E_Temp -= 1
+
+        # E_Temp limit
+        if self.pd.HMI_ValueStruct.E_Temp > self.pd.MAX_E_TEMP:
+            self.pd.HMI_ValueStruct.E_Temp = self.pd.MAX_E_TEMP
+        if self.pd.HMI_ValueStruct.E_Temp < self.pd.MIN_E_TEMP:
+            self.pd.HMI_ValueStruct.E_Temp = self.pd.MIN_E_TEMP
+        # E_Temp value
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            3,
+            200,
+            self.MBASE(temp_line) - 8,
+            self.pd.HMI_ValueStruct.E_Temp,
+        )
+
+    def HMI_BedTemp(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+        if self.pd.HMI_ValueStruct.show_mode == -1:
+            bed_line = self.TEMP_CASE_BED
+        elif self.pd.HMI_ValueStruct.show_mode == -2:
+            bed_line = self.PREHEAT_CASE_BED
+        elif self.pd.HMI_ValueStruct.show_mode == -3:
+            bed_line = self.PREHEAT_CASE_BED
+        else:
+            bed_line = self.TUNE_CASE_TEMP + self.MROWS - self.index_tune
+
+        if encoder_state == self.ENCODER_DIFF_ENTER:
+            self.EncoderRateLimit = True
+            if self.pd.HMI_ValueStruct.show_mode == -1:  # temperature
+                self.checkkey = self.TemperatureID
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(bed_line) - 8,
+                    self.pd.HMI_ValueStruct.Bed_Temp,
+                )
+            elif self.pd.HMI_ValueStruct.show_mode == -2:
+                self.checkkey = self.PLAPreheat
+                self.pd.material_preset[0].bed_temp = self.pd.HMI_ValueStruct.Bed_Temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(bed_line) - 8,
+                    self.pd.material_preset[0].bed_temp,
+                )
+                return
+            elif self.pd.HMI_ValueStruct.show_mode == -3:
+                self.checkkey = self.TPUPreheat
+                self.pd.material_preset[1].bed_temp = self.pd.HMI_ValueStruct.Bed_Temp
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(bed_line) - 8,
+                    self.pd.material_preset[1].bed_temp,
+                )
+                return
+            else:  # tune
+                self.checkkey = self.Tune
+                self.lcd.draw_int_value(
+                    True,
+                    True,
+                    0,
+                    self.lcd.font_8x8,
+                    self.color_yellow,
+                    self.color_background_black,
+                    3,
+                    200,
+                    self.MBASE(bed_line) - 8,
+                    self.pd.HMI_ValueStruct.Bed_Temp,
+                )
+                self.pd.setTargetHotend(self.pd.HMI_ValueStruct.Bed_Temp, 0)
+            return
+
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.Bed_Temp += 1
+
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.Bed_Temp -= 1
+
+        # Bed_Temp limit
+        if self.pd.HMI_ValueStruct.Bed_Temp > self.pd.BED_MAX_TARGET:
+            self.pd.HMI_ValueStruct.Bed_Temp = self.pd.BED_MAX_TARGET
+        if self.pd.HMI_ValueStruct.Bed_Temp < self.pd.MIN_BED_TEMP:
+            self.pd.HMI_ValueStruct.Bed_Temp = self.pd.MIN_BED_TEMP
+        # Bed_Temp value
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            3,
+            200,
+            self.MBASE(bed_line) - 8,
+            self.pd.HMI_ValueStruct.Bed_Temp,
+        )
+
+    # ---------------------Todo--------------------------------#
+
+    def HMI_Motion(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        if encoder_state == self.ENCODER_DIFF_CW:
+            if self.select_motion.inc(1 + self.MOTION_CASE_TOTAL):
+                self.Move_Highlight(1, self.select_motion.now)
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            if self.select_motion.dec():
+                self.Move_Highlight(-1, self.select_motion.now)
+        elif encoder_state == self.ENCODER_DIFF_ENTER:
+            if self.select_motion.now == 0:  # back
+                self.checkkey = self.Control
+                self.select_control.set(self.CONTROL_CASE_MOVE)
+                self.index_control = self.MROWS
+                self.Draw_Control_Menu()
+            else:
+                # Max speed, acceleration and steps per mm menu
+                # are not implemented yet. Popup a "feature not
+                # available" window and return to motion menu
+                # when confirm is pressed.
+                self.popup_caller = self.Motion
+                self.checkkey = self.FeatureNotAvailable
+                self.Draw_FeatureNotAvailable_Popup()
+
+    def HMI_Zoffset(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+        zoff_line = 0
+        if self.pd.HMI_ValueStruct.show_mode == -4:
+            zoff_line = self.PREPARE_CASE_ZOFF + self.MROWS - self.index_prepare
+        else:
+            zoff_line = self.TUNE_CASE_ZOFF + self.MROWS - self.index_tune
+
+        if (
+            encoder_state == self.ENCODER_DIFF_ENTER
+        ):  # if (applyencoder(encoder_diffstate, offset_value))
+            self.EncoderRateLimit = True
+            if self.pd.HAS_BED_PROBE:
+                self.pd.offset_z(self.dwin_zoffset)
+            else:
+                self.pd.setZOffset(self.dwin_zoffset)  # manually set
+
+            self.checkkey = (
+                self.Prepare if self.pd.HMI_ValueStruct.show_mode == -4 else self.Tune
+            )
+            self.lcd.draw_signed_float(
+                True,
+                self.lcd.font_8x8,
+                self.color_yellow,
+                self.color_background_black,
+                2,
+                3,
+                175,
+                self.MBASE(zoff_line) - 10,
+                self.pd.HMI_ValueStruct.offset_value,
+            )
+
+            return
+
+        elif encoder_state == self.ENCODER_DIFF_CW:
+            self.pd.HMI_ValueStruct.offset_value += 1
+        elif encoder_state == self.ENCODER_DIFF_CCW:
+            self.pd.HMI_ValueStruct.offset_value -= 1
+
+        if (
+            self.pd.HMI_ValueStruct.offset_value
+            < (self.pd.Z_PROBE_OFFSET_RANGE_MIN) * 100
+        ):
+            self.pd.HMI_ValueStruct.offset_value = (
+                self.pd.Z_PROBE_OFFSET_RANGE_MIN * 100
+            )
+        elif (
+            self.pd.HMI_ValueStruct.offset_value
+            > (self.pd.Z_PROBE_OFFSET_RANGE_MAX) * 100
+        ):
+            self.pd.HMI_ValueStruct.offset_value = (
+                self.pd.Z_PROBE_OFFSET_RANGE_MAX * 100
+            )
+
+        self.last_zoffset = self.dwin_zoffset
+        self.dwin_zoffset = self.pd.HMI_ValueStruct.offset_value / 100.0
+        if self.pd.HAS_BED_PROBE:
+            self.pd.add_mm("Z", self.dwin_zoffset - self.last_zoffset)
+
+        self.lcd.draw_signed_float(
+            True,
+            self.lcd.font_8x8,
+            self.color_yellow,
+            self.color_background_black,
+            2,
+            3,
+            175,
+            self.MBASE(zoff_line) - 10,
+            self.pd.HMI_ValueStruct.offset_value,
+        )
+
+    def HMI_MaxSpeed(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_MaxAcceleration(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_MaxJerk(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_Step(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_MaxFeedspeedXYZE(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_MaxAccelerationXYZE(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_MaxJerkXYZE(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    def HMI_StepXYZE(self):
+        encoder_state = self.get_encoder_state()
+        if encoder_state == self.ENCODER_DIFF_NO:
+            return
+
+    # --------------------------------------------------------------#
+
+    def Draw_Status_Area(self, with_update=True):
+        #  Clear the bottom area of the screen
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            0,
+            self.STATUS_Y,
+            self.lcd.screen_width,
+            self.lcd.screen_height - 1,
+        )
+
+        # nozzle temp area
+
+        self.lcd.draw_icon(True, self.ICON, self.icon_hotend_temp, 6, 262)
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            26,
+            268,
+            self.pd.thermalManager["temp_hotend"][0]["celsius"],
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            26 + 3 * self.STAT_CHR_W + 4,
+            268,
+            "/",
+        )
+        self.lcd.draw_int_value(
+            False,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            26 + 3 * self.STAT_CHR_W + 5,
+            268,
+            self.pd.thermalManager["temp_hotend"][0]["target"],
+        )
+
+        # bed temp area
+        self.lcd.draw_icon(True, self.ICON, self.icon_bedtemp, 6, 294)
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            26,
+            300,
+            self.pd.thermalManager["temp_bed"]["celsius"],
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            26 + 3 * self.STAT_CHR_W + 4,
+            300,
+            "/",
+        )
+        self.lcd.draw_int_value(
+            False,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            26 + 3 * self.STAT_CHR_W + 5,
+            300,
+            self.pd.thermalManager["temp_bed"]["target"],
+        )
+
+        # speed area
+        self.lcd.draw_icon(True, self.ICON, self.icon_speed, 99, 262)
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            99 + 2 * self.STAT_CHR_W,
+            268,
+            self.pd.feedrate_percentage,
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            99 + 5 * self.STAT_CHR_W + 2,
+            268,
+            "%",
+        )
+
+        # extrude area
+        self.lcd.draw_icon(True, self.ICON, self.icon_MaxSpeedE, 99, 294)
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            99 + 2 * self.STAT_CHR_W,
+            300,
+            self.pd.feedrate_percentage,
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            99 + 5 * self.STAT_CHR_W + 2,
+            300,
+            "%",
+        )
+
+        # fan speed area
+        self.lcd.draw_icon(True, self.ICON, self.icon_FanSpeed, 165, 262)
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            165 + 2 * self.STAT_CHR_W,
+            268,
+            self.pd.feedrate_percentage,
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            165 + 5 * self.STAT_CHR_W + 2,
+            268,
+            "%",
+        )
+
+        # Z offset area
+        self.lcd.draw_icon(True, self.ICON, self.icon_z_offset, 165, 294)
+        self.lcd.draw_signed_float(
+            True,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            1,
+            3,
+            191,
+            300,
+            self.pd.BABY_Z_VAR * 100,
+        )
+
+        if with_update:
+            time.sleep(0.005)
+
+    def Draw_Title(self, title):
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_12x24,
+            self.color_white,
+            self.color_background_grey,
+            14,
+            4,
+            title,
+        )
+
+    def Draw_Popup_Bkgd_105(self):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_popup_background,
+            6,
+            self.HEADER_HEIGHT + 6,
+            self.lcd.screen_width - 6,
+            self.STATUS_Y + 78,
+        )
+
+    def Draw_More_Icon(self, line):
+        self.lcd.draw_icon(True, self.ICON, self.icon_more, 206, self.MBASE(line) - 14)
+
+    def Draw_Menu_Cursor(self, line):
+        self.lcd.draw_rectangle(
+            1,
+            self.Rectangle_color,
+            0,
+            self.MBASE(line) - 18,
+            10,
+            self.MBASE(line + 1) - 20,
+        )
+
+    def Draw_Menu_Icon(self, line, icon):
+        self.lcd.draw_icon(True, self.ICON, icon, 20, self.MBASE(line) - 14)
+
+    def Draw_Menu_Text_Icon(self, line, text_icon):
+        self.lcd.draw_icon(
+            True, self.selected_language, text_icon, self.LBLX, self.MBASE(line) - 16
+        )
+
+    def Draw_Menu_Line(self, line, icon=False, label=False):
+        if label:
+            self.lcd.draw_rectangle(
+                1,
+                self.color_background_black,
+                self.LBLX,
+                self.MBASE(line) - 5,
+                self.lcd.screen_width,
+                self.MBASE(line + 1) - 22,
+            )
+            self.lcd.draw_string(
+                True,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                self.LBLX,
+                self.MBASE(line) - 5,
+                label,
+            )
+        if icon:
+            self.Draw_Menu_Icon(line, icon)
+        self.lcd.draw_line(
+            self.color_line,
+            15,
+            self.MBASE(line + 1) - 22,
+            235,
+            self.MBASE(line + 1) - 22,
+        )
+
+    def Draw_Menu_Line_With_Only_Icons(
+        self, line, icon_left=False, text_icon=False, dividing_line=True
+    ):
+        if icon_left:
+            self.Draw_Menu_Icon(line, icon_left)
+        if text_icon:
+            self.lcd.draw_rectangle(
+                1,
+                self.color_background_black,
+                self.LBLX,
+                self.MBASE(line) - 5,
+                self.lcd.screen_width,
+                self.MBASE(line + 1) - 22,
+            )
+            self.Draw_Menu_Text_Icon(line, text_icon)
+        if dividing_line:
+            self.lcd.draw_line(
+                self.color_line,
+                15,
+                self.MBASE(line + 1) - 22,
+                235,
+                self.MBASE(line + 1) - 22,
+            )
+
+    # Draw "Back" line at the top
+    def Draw_Back_First(self, is_sel=True):
+        self.Draw_Menu_Line_With_Only_Icons(0, self.icon_back, self.icon_TEXT_back)
+
+        if is_sel:
+            self.Draw_Menu_Cursor(0)
+
+    def draw_move_en(self, line):
+        self.lcd.move_screen_area(1, 69, 61, 102, 71, self.LBLX, line)  # "Move"
+
+    def draw_max_en(self, line):
+        self.lcd.move_screen_area(1, 245, 119, 269, 129, self.LBLX, line)  # "Max"
+
+    def draw_max_accel_en(self, line):
+        self.draw_max_en(line)
+        self.lcd.move_screen_area(
+            1, 1, 135, 79, 145, self.LBLX + 27, line
+        )  # "Acceleration"
+
+    def draw_speed_en(self, inset, line):
+        self.lcd.move_screen_area(
+            1, 184, 119, 224, 132, self.LBLX + inset, line
+        )  # "Speed"
+
+    def draw_jerk_en(self, line):
+        self.lcd.move_screen_area(1, 64, 119, 106, 129, self.LBLX + 27, line)  # "Jerk"
+
+    def draw_steps_per_mm(self, line):
+        self.lcd.move_screen_area(
+            1, 1, 151, 101, 161, self.LBLX, line
+        )  # "Steps-per-mm"
+
+    # Display an SD item
+    def Draw_SDItem(self, item, row=0):
+        fl = self.pd.GetFiles()[item]
+        self.Draw_Menu_Line(row, self.icon_file, fl)
+
+    def Draw_Select_Highlight(self, sel):
+        self.pd.HMI_flag.select_flag = sel
+        if sel:
+            c1 = self.color_background_black
+            c2 = self.color_popup_background
+        else:
+            c1 = self.color_popup_background
+            c2 = self.color_background_black
+        self.lcd.draw_rectangle(0, c1, 30, 154, 111, 185)
+        self.lcd.draw_rectangle(0, c2, 129, 154, 211, 186)
+
+    def Draw_Printing_Screen(self):
+        # Tune
+        self.lcd.draw_icon(True, self.ICON, self.icon_tune, 12, 191)
+        self.lcd.draw_icon(False, self.selected_language, self.icon_TEXT_Tune, 12, 225)
+        # Pause
+        self.lcd.draw_icon(True, self.ICON, self.icon_pause, 86, 191)
+        self.lcd.draw_icon(False, self.selected_language, self.icon_TEXT_Pause, 86, 225)
+        # Stop
+        self.lcd.draw_icon(True, self.ICON, self.icon_stop, 160, 191)
+        self.lcd.draw_icon(False, self.selected_language, self.icon_TEXT_Stop, 160, 225)
+        # Print elapsed time
+        self.lcd.draw_icon(True, self.ICON, self.icon_print_time, 117, 77)
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_text_printing_time, 170, 61
+        )
+        # Print remain time
+        self.lcd.draw_icon(True, self.ICON, self.icon_remain_time, 117, 138)
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_text_remain_time, 170, 122
+        )
+
+    def Draw_Print_ProgressBar(self, Percentrecord=None):
+        if not Percentrecord:
+            Percentrecord = self.pd.getPercent()
+        progress_icon_id = self.icon_progress_0 + Percentrecord
+        self.lcd.draw_icon(True, self.GIF_ICON, progress_icon_id, 12, 75)
+
+    def Draw_Print_ProgressElapsed(self):
+        elapsed = self.pd.duration()  # print timer
+        self.lcd.draw_int_value(
+            False,
+            True,
+            1,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            2,
+            160,
+            100,
+            elapsed / 3600,
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            183,
+            100,
+            ":",
+        )
+        self.lcd.draw_int_value(
+            False,
+            True,
+            1,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            2,
+            190,
+            100,
+            (elapsed % 3600) / 60,
+        )
+
+    def Draw_Print_ProgressRemain(self):
+        remain_time = self.pd.remain()
+        if not remain_time:
+            return  # time remaining is None during warmup.
+        self.lcd.draw_int_value(
+            False,
+            True,
+            1,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            2,
+            160,
+            166,
+            remain_time / 3600,
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            183,
+            166,
+            ":",
+        )
+        self.lcd.draw_int_value(
+            False,
+            True,
+            1,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            2,
+            190,
+            166,
+            (remain_time % 3600) / 60,
+        )
+
+    def Draw_Print_File_Menu(self):
+        self.Clear_Title_Bar()
+        # Draw "File Selection" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_file_selection,
+            self.HEADER_HEIGHT,
+            1,
+        )
+        self.Redraw_SD_List()
+        self.Draw_Status_Area()
+
+    def Draw_Prepare_Menu(self):
+        self.Clear_Main_Window()
+        # Draw "Prepare" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_prepare,
+            self.HEADER_HEIGHT,
+            1,
+        )
+
+        scroll = self.MROWS - self.index_prepare
+        # self.Frame_TitleCopy(1, 178, 2, 229, 14)  # "Prepare"
+        self.Draw_Back_First(self.select_prepare.now == 0)  # < Back
+        if scroll + self.PREPARE_CASE_MOVE <= self.MROWS:
+            self.Item_Prepare_Move(self.PREPARE_CASE_MOVE)  # Move >
+        if scroll + self.PREPARE_CASE_DISA <= self.MROWS:
+            self.Item_Prepare_Disable(self.PREPARE_CASE_DISA)  # Disable Stepper
+        if scroll + self.PREPARE_CASE_HOME <= self.MROWS:
+            self.Item_Prepare_Home(self.PREPARE_CASE_HOME)  # Auto Home
+        if self.pd.HAS_ZOFFSET_ITEM:
+            if scroll + self.PREPARE_CASE_ZOFF <= self.MROWS:
+                self.Item_Prepare_Offset(
+                    self.PREPARE_CASE_ZOFF
+                )  # Edit Z-Offset / Babystep / Set Home Offset
+        if self.pd.HAS_HOTEND:
+            if scroll + self.PREPARE_CASE_PLA <= self.MROWS:
+                self.Item_Prepare_PLA(self.PREPARE_CASE_PLA)  # Preheat PLA
+            if scroll + self.PREPARE_CASE_TPU <= self.MROWS:
+                self.Item_Prepare_TPU(self.PREPARE_CASE_TPU)  # Preheat TPU
+        if self.pd.HAS_PREHEAT:
+            if scroll + self.PREPARE_CASE_COOL <= self.MROWS:
+                self.Item_Prepare_Cool(self.PREPARE_CASE_COOL)  # Cooldown
+        if self.select_prepare.now:
+            self.Draw_Menu_Cursor(self.select_prepare.now)
+        self.Draw_Status_Area()
+
+    def Draw_Control_Menu(self):
+        self.Clear_Main_Window()
+        # Draw "Control" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_control,
+            self.HEADER_HEIGHT,
+            1,
+        )
+
+        self.Draw_Back_First(self.select_control.now == 0)
+
+        # self.Frame_TitleCopy(1, 128, 2, 176, 12)
+        # self.lcd.move_screen_area(1, 1, 89, 83, 101, self.LBLX, self.MBASE(self.CONTROL_CASE_TEMP))  # Temperature >
+        # self.lcd.move_screen_area(1, 84, 89, 128, 99, self.LBLX, self.MBASE(self.CONTROL_CASE_MOVE))  # Motion >
+        # self.lcd.move_screen_area(1, 0, 104, 25, 115, self.LBLX, self.MBASE(self.CONTROL_CASE_INFO))  # Info >
+
+        if self.select_control.now and self.select_control.now < self.MROWS:
+            self.Draw_Menu_Cursor(self.select_control.now)
+
+        # # Draw icons and lines
+        self.Draw_Menu_Line_With_Only_Icons(
+            1, self.icon_temperature, self.icon_TEXT_temperature
+        )
+        self.Draw_More_Icon(1)
+        self.Draw_Menu_Line_With_Only_Icons(2, self.icon_motion, self.icon_TEXT_motion)
+        self.Draw_More_Icon(2)
+        self.Draw_Menu_Line_With_Only_Icons(3, self.icon_info, self.icon_TEXT_Info)
+        self.Draw_More_Icon(3)
+        self.Draw_Status_Area()
+
+    def Draw_Leveling_Menu(self):
+        self.Clear_Main_Window()
+
+    def Draw_Info_Menu(self):
+        """
+        Draws the "Info" menu on the display.
+        As the text stays on the bottom of each line instead of
+        a normal menu item, this is manually drawn.
+        """
+        self.Clear_Main_Window()
+        # Draw "Info" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_info,
+            self.HEADER_HEIGHT,
+            1,
+        )
+
+        self.Draw_Back_First()
+
+        # Bed size 80,95,110,140,155,170,200,215,230,260
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_TEXT_bed_size, self.LBLX, 75
+        )
+        self.lcd.draw_icon(True, self.ICON, self.icon_PrintSize, 20, 90)
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_6x12,
+            self.color_white,
+            self.color_background_black,
+            70,
+            105,
+            self.pd.MACHINE_SIZE,
+        )
+
+        # Klipper version
+        self.lcd.draw_icon(
+            True,
+            self.selected_language,
+            self.icon_TEXT_hardware_version,
+            self.LBLX,
+            135,
+        )
+        self.lcd.draw_icon(True, self.ICON, self.icon_Version, 20, 140)
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_6x12,
+            self.color_white,
+            self.color_background_black,
+            50,
+            155,
+            "Klipper " + self.pd.SHORT_BUILD_VERSION,
+        )
+
+        # Contact details
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_TEXT_contact, self.LBLX, 185
+        )
+        self.lcd.draw_icon(True, self.ICON, self.icon_Contact, 20, 200)
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            50,
+            215,
+            "github.com/jpcurti/",
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            30,
+            230,
+            "ender3-v3-se-klipper-with-display",
+        )
+        self.Draw_Status_Area()
+
+    def Draw_Tune_Menu(self):
+        self.Clear_Main_Window()
+        # Draw "Tune" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_tune,
+            self.HEADER_HEIGHT,
+            1,
+        )
+        self.lcd.move_screen_area(1, 94, 2, 126, 12, 14, 9)
+        self.lcd.move_screen_area(
+            1, 1, 179, 92, 190, self.LBLX, self.MBASE(self.TUNE_CASE_SPEED)
+        )  # Print speed
+        if self.pd.HAS_HOTEND:
+            self.lcd.move_screen_area(
+                1, 197, 104, 238, 114, self.LBLX, self.MBASE(self.TUNE_CASE_TEMP)
+            )  # Hotend...
+            self.lcd.move_screen_area(
+                1, 1, 89, 83, 101, self.LBLX + 44, self.MBASE(self.TUNE_CASE_TEMP)
+            )  # Temperature
+        if self.pd.HAS_HEATED_BED:
+            self.lcd.move_screen_area(
+                1, 240, 104, 264, 114, self.LBLX, self.MBASE(self.TUNE_CASE_BED)
+            )  # Bed...
+            self.lcd.move_screen_area(
+                1, 1, 89, 83, 101, self.LBLX + 27, self.MBASE(self.TUNE_CASE_BED)
+            )  # ...Temperature
+        if self.pd.HAS_FAN:
+            self.lcd.move_screen_area(
+                1, 0, 119, 64, 132, self.LBLX, self.MBASE(self.TUNE_CASE_FAN)
+            )  # Fan speed
+        if self.pd.HAS_ZOFFSET_ITEM:
+            self.lcd.move_screen_area(
+                1, 93, 179, 141, 189, self.LBLX, self.MBASE(self.TUNE_CASE_ZOFF)
+            )  # Z-offset
+        self.Draw_Back_First(self.select_tune.now == 0)
+        if self.select_tune.now:
+            self.Draw_Menu_Cursor(self.select_tune.now)
+
+        self.Draw_Menu_Line_With_Only_Icons(
+            self.TUNE_CASE_SPEED, self.icon_speed, self.icon_TEXT_Printing_Speed
+        )
+        self.lcd.draw_int_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            200,
+            self.MBASE(self.TUNE_CASE_SPEED) - 8,
+            self.pd.feedrate_percentage,
+        )
+
+        if self.pd.HAS_HOTEND:
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TUNE_CASE_TEMP,
+                self.icon_hotend_temp,
+                self.icon_TEXT_nozzle_temperature,
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(self.TUNE_CASE_TEMP) - 8,
+                self.pd.thermalManager["temp_hotend"][0]["target"],
+            )
+
+        if self.pd.HAS_HEATED_BED:
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TUNE_CASE_BED, self.icon_bedtemp, self.icon_TEXT_bed_temperature
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(self.TUNE_CASE_BED) - 8,
+                self.pd.thermalManager["temp_bed"]["target"],
+            )
+
+        if self.pd.HAS_FAN:
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TUNE_CASE_FAN, self.icon_FanSpeed, self.icon_TEXT_fan_speed
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(self.TUNE_CASE_FAN) - 8,
+                self.pd.thermalManager["fan_speed"][0],
+            )
+        if self.pd.HAS_ZOFFSET_ITEM:
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TUNE_CASE_ZOFF, self.icon_z_offset, self.icon_TEXT_Z_Offset
+            )
+            self.lcd.draw_signed_float(
+                True,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                2,
+                3,
+                175,
+                self.MBASE(self.TUNE_CASE_ZOFF) - 10,
+                self.pd.BABY_Z_VAR * 100,
+            )
+
+    def Draw_Temperature_Menu(self):
+        self.Clear_Main_Window()
+        # Draw "Temperature" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_temperature,
+            self.HEADER_HEIGHT,
+            1,
+        )
+
+        self.Draw_Back_First(self.select_temp.now == 0)
+        if self.select_temp.now:
+            self.Draw_Menu_Cursor(self.select_temp.now)
+
+        # Draw icons and lines
+        i = 0
+        if self.pd.HAS_HOTEND:
+            i += 1
+            # self.Draw_Menu_Line( self.TEMP_CASE_TEMP, self.icon_SetEndTemp, "Nozzle Temperature")
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TEMP_CASE_TEMP,
+                self.icon_SetEndTemp,
+                self.icon_TEXT_nozzle_temperature,
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(i) - 8,
+                self.pd.thermalManager["temp_hotend"][0]["target"],
+            )
+        if self.pd.HAS_HEATED_BED:
+            i += 1
+            # self.Draw_Menu_Line( (self.TEMP_CASE_BED), self.icon_SetEndTemp, "Bed Temperature")
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TEMP_CASE_BED, self.icon_SetEndTemp, self.icon_TEXT_bed_temperature
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(i) - 8,
+                self.pd.thermalManager["temp_bed"]["target"],
+            )
+        if self.pd.HAS_FAN:
+            i += 1
+            self.Draw_Menu_Line_With_Only_Icons(
+                (self.TEMP_CASE_FAN),
+                self.icon_SetEndTemp,
+                self.icon_TEXT_nozzle_temperature,
+            )
+            self.lcd.draw_int_value(
+                True,
+                True,
+                0,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                3,
+                200,
+                self.MBASE(i) - 8,
+                self.pd.thermalManager["fan_speed"][0],
+            )
+        if self.pd.HAS_HOTEND:
+            # PLA/TPU items have submenus
+            i += 1
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TEMP_CASE_PLA,
+                self.icon_SetEndTemp,
+                self.icon_TEXT_preheat_pla_settings,
+            )
+            self.Draw_More_Icon(i)
+            i += 1
+            self.Draw_Menu_Line_With_Only_Icons(
+                self.TEMP_CASE_TPU,
+                self.icon_SetEndTemp,
+                self.icon_TEXT_preheat_tpu_settings,
+            )
+            self.Draw_More_Icon(i)
+
+    def Draw_Motion_Menu(self):
+        self.Clear_Main_Window()
+        # Draw "Motion" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_motion,
+            self.HEADER_HEIGHT,
+            1,
+        )
+        self.draw_max_en(self.MBASE(self.MOTION_CASE_RATE))
+        self.draw_speed_en(27, self.MBASE(self.MOTION_CASE_RATE))  # "Max Speed"
+        self.draw_max_accel_en(self.MBASE(self.MOTION_CASE_ACCEL))  # "Max Acceleration"
+        self.draw_steps_per_mm(self.MBASE(self.MOTION_CASE_STEPS))  # "Steps-per-mm"
+
+        self.Draw_Back_First(self.select_motion.now == 0)
+        if self.select_motion.now:
+            self.Draw_Menu_Cursor(self.select_motion.now)
+
+        self.Draw_Menu_Line_With_Only_Icons(
+            self.MOTION_CASE_RATE, self.icon_MaxSpeed, self.icon_TEXT_max_speed
+        )
+        self.Draw_More_Icon(self.MOTION_CASE_RATE)
+
+        self.Draw_Menu_Line_With_Only_Icons(
+            self.MOTION_CASE_ACCEL,
+            self.icon_MaxAccelerated,
+            self.icon_TEXT_max_acceleration,
+        )
+        self.Draw_More_Icon(self.MOTION_CASE_ACCEL)
+
+        self.Draw_Menu_Line_With_Only_Icons(
+            self.MOTION_CASE_STEPS, self.icon_Step, self.icon_TEXT_steps_per_mm
+        )
+        self.Draw_More_Icon(self.MOTION_CASE_STEPS)
+
+    def Draw_Move_Menu(self):
+        """
+        Only visual: Draws the "Move" menu on the display.
+
+        This method clears the main window and then proceeds to draw the "Move" header.
+        It also draws the options for moving the X, Y, and Z axes, as well as the extruder
+        option if available. It also handles drawing the menu cursor and separators.
+        """
+        self.Clear_Main_Window()
+        # Draw "Move" on header
+        self.lcd.draw_icon(
+            False,
+            self.selected_language,
+            self.icon_TEXT_header_move,
+            self.HEADER_HEIGHT,
+            1,
+        )
+
+        self.Draw_Back_First(self.select_axis.now == 0)
+        if self.select_axis.now:
+            self.Draw_Menu_Cursor(self.select_axis.now)
+
+        line_count = 1
+        self.Draw_Menu_Line_With_Only_Icons(
+            line_count, self.icon_move_x, self.icon_TEXT_move_x
+        )
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(line_count) - 10,
+            self.pd.current_position.x * self.MINUNITMULT,
+        )
+
+        line_count += 1
+        self.Draw_Menu_Line_With_Only_Icons(
+            line_count, self.icon_move_y, self.icon_TEXT_move_y
+        )
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(line_count) - 10,
+            self.pd.current_position.y * self.MINUNITMULT,
+        )
+
+        line_count += 1
+        self.Draw_Menu_Line_With_Only_Icons(
+            line_count, self.icon_move_z, self.icon_TEXT_move_z
+        )
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(line_count) - 10,
+            self.pd.current_position.z * self.MINUNITMULT,
+        )
+
+        line_count += 1
+        self.Draw_Menu_Line_With_Only_Icons(
+            line_count, self.icon_move_e, self.icon_TEXT_move_e
+        )
+        self.lcd.draw_float_value(
+            True,
+            True,
+            0,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_background_black,
+            3,
+            1,
+            175,
+            self.MBASE(line_count) - 10,
+            self.pd.current_position.e * self.MINUNITMULT,
+        )
+
+    def Goto_MainMenu(self):
+        self.checkkey = self.MainMenu
+        self.Clear_Screen()
+        # Draw "Main" on header
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_TEXT_header_main, 29, 1
+        )
+
+        self.icon_Print()
+        self.icon_Prepare()
+        self.icon_Control()
+        if self.pd.HAS_ONESTEP_LEVELING:
+            self.icon_Leveling(self.select_page.now == 3)
+        else:
+            self.icon_StartInfo(self.select_page.now == 3)
+
+    def Goto_PrintProcess(self):
+        self.checkkey = self.PrintProcess
+        self.Clear_Main_Window()
+        # Draw "Printing" on header
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_TEXT_header_printing, 29, 1
+        )
+        self.Draw_Printing_Screen()
+
+        self.show_tune()
+        if self.pd.printingIsPaused():
+            self.show_continue()
+        else:
+            self.show_pause()
+        self.show_stop()
+
+        # Copy into filebuf string before entry
+        name = self.pd.file_name
+        if name:
+            npos = _MAX(0, self.lcd.screen_width - len(name) * self.MENU_CHR_W) / 2
+            self.lcd.draw_string(
+                False,
+                self.lcd.font_6x12,
+                self.color_white,
+                self.color_background_black,
+                npos,
+                40,
+                name,
+            )
+
+        self.Draw_Print_ProgressBar()
+        self.Draw_Print_ProgressElapsed()
+        self.Draw_Print_ProgressRemain()
+        self.Draw_Status_Area()
+
+    # --------------------------------------------------------------#
+    # --------------------------------------------------------------#
+
+    def Clear_Title_Bar(self):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_grey,
+            0,
+            0,
+            self.lcd.screen_width,
+            self.HEADER_HEIGHT,
+        )
+
+    def Clear_Menu_Area(self):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            0,
+            self.HEADER_HEIGHT,
+            self.lcd.screen_width,
+            self.STATUS_Y,
+        )
+
+    def Clear_Status_Area(self):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            0,
+            self.STATUS_Y,
+            self.lcd.screen_width,
+            self.lcd.screen_height,
+        )
+
+    def Clear_Main_Window(self):
+        self.Clear_Title_Bar()
+        self.Clear_Menu_Area()
+
+    def Clear_Screen(self):
+        self.Clear_Title_Bar()
+        self.Clear_Menu_Area()
+        self.Clear_Status_Area()
+
+    def Clear_Popup_Area(self):
+        self.Clear_Title_Bar()
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            0,
+            31,
+            self.lcd.screen_width,
+            self.lcd.screen_height,
+        )
+
+    def Popup_window_PauseOrStop(self):
+        self.Clear_Main_Window()
+        if self.select_print.now == 1:
+            self.lcd.draw_icon(
+                True,
+                self.selected_language,
+                self.icon_popup_pause_print,
+                15,
+                self.HEADER_HEIGHT + 50,
+            )
+
+        elif self.select_print.now == 2:
+            self.lcd.draw_icon(
+                True,
+                self.selected_language,
+                self.icon_popup_stop_print,
+                15,
+                self.HEADER_HEIGHT + 50,
+            )
+        self.lcd.draw_rectangle(
+            0, self.color_white, 15, self.HEADER_HEIGHT + 50, 225, 195
+        )
+        self.lcd.draw_icon(
+            True,
+            self.selected_language,
+            self.icon_confim_button_hovered,
+            30,
+            self.HEADER_HEIGHT + 130,
+        )
+        self.lcd.draw_icon(
+            True,
+            self.selected_language,
+            self.icon_cancel_button_hovered,
+            130,
+            self.HEADER_HEIGHT + 130,
+        )
+        self.Draw_Select_Highlight(True)
+
+    def Popup_Window_Home(self):
+        """
+        Displays a popup window indicating that the printer is homing.
+        """
+        self.Clear_Main_Window()
+        self.lcd.draw_icon(
+            True,
+            self.selected_language,
+            self.icon_popup_homing,
+            18,
+            self.HEADER_HEIGHT + 60,
+        )
+
+    def Popup_Window_ETempTooLow(self):
+        """
+        Displays a popup window indicating that the extruder temperature is too low.
+        """
+        self.Clear_Main_Window()
+        self.lcd.draw_rectangle(
+            1, self.color_popup_background, 15, self.HEADER_HEIGHT + 50, 225, 195
+        )
+        self.lcd.draw_icon(
+            True,
+            self.selected_language,
+            self.icon_popup_nozzle_temp_too_low,
+            15,
+            self.HEADER_HEIGHT + 50,
+        )
+        self.lcd.draw_rectangle(
+            0, self.color_white, 15, self.HEADER_HEIGHT + 50, 225, 195
+        )
+
+        # Draw ok button
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_confim_button_hovered, 80, 154
+        )
+        self.lcd.draw_rectangle(0, self.color_white, 80, 154, 160, 185)
+
+    def Draw_FeatureNotAvailable_Popup(self):
+        """
+        Displays a popup window indicating that this feature is not available.
+        """
+        # self.Clear_Main_Window()
+        self.lcd.draw_rectangle(
+            1, self.color_popup_background, 15, self.HEADER_HEIGHT + 50, 225, 195
+        )
+        self.lcd.draw_rectangle(
+            0, self.color_white, 15, self.HEADER_HEIGHT + 50, 225, 195
+        )
+        # Draw text with "Feature not available on the screen. Please use klipper"
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_popup_background,
+            20,
+            self.HEADER_HEIGHT + 55,
+            "Feature not available on",
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_popup_background,
+            20,
+            self.HEADER_HEIGHT + 75,
+            "the screen yet, please",
+        )
+        self.lcd.draw_string(
+            False,
+            self.lcd.font_8x8,
+            self.color_white,
+            self.color_popup_background,
+            20,
+            self.HEADER_HEIGHT + 95,
+            "use the klipper interface.",
+        )
+        # Draw ok button
+        self.lcd.draw_icon(
+            True, self.selected_language, self.icon_confim_button_hovered, 80, 154
+        )
+        self.lcd.draw_rectangle(0, self.color_white, 80, 154, 160, 185)
+
+    def Erase_Menu_Cursor(self, line):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            0,
+            self.MBASE(line) - 18,
+            14,
+            self.MBASE(line + 1) - 20,
+        )
+
+    def Erase_Menu_Text(self, line):
+        self.lcd.draw_rectangle(
+            1,
+            self.color_background_black,
+            self.LBLX,
+            self.MBASE(line) - 14,
+            271,
+            self.MBASE(line) + 28,
+        )
+
+    def Move_Highlight(self, ffrom, newline):
+        self.Erase_Menu_Cursor(newline - ffrom)
+        self.Draw_Menu_Cursor(newline)
+
+    def Add_Menu_Line(self):
+        self.Move_Highlight(1, self.MROWS)
+        self.lcd.draw_line(
+            self.color_line,
+            18,
+            self.MBASE(self.MROWS + 1) - 22,
+            238,
+            self.MBASE(self.MROWS + 1) - 22,
+        )
+
+    def Scroll_Menu(self, dir):
+        self.lcd.move_screen_area(
+            dir,
+            self.MLINE,
+            self.color_background_grey,
+            12,
+            self.HEADER_HEIGHT,
+            self.lcd.screen_width - 1,
+            self.STATUS_Y,
+        )
+        if dir == self.scroll_down:
+            self.Move_Highlight(-1, 0)
+        elif dir == self.scroll_up:
+            self.Add_Menu_Line()
+
+    # Redraw the first set of SD Files
+    def Redraw_SD_List(self):
+        self.select_file.reset()
+        self.index_file = self.MROWS
+        self.Clear_Menu_Area()  # Leave title bar unchanged, clear only middle of screen
+        self.Draw_Back_First()
+        fl = self.pd.GetFiles()
+        ed = len(fl)
+        if ed > 0:
+            if ed > self.MROWS:
+                ed = self.MROWS
+            for i in range(ed):
+                self.Draw_SDItem(i, i + 1)
+        else:
+            self.lcd.draw_rectangle(
+                1,
+                self.color_Bg_Red,
+                11,
+                25,
+                self.MBASE(3) - 10,
+                self.lcd.screen_width - 10,
+                self.MBASE(4),
+            )
+            self.lcd.draw_string(
+                False,
+                self.lcd.font_16x32,
+                self.color_yellow,
+                self.color_Bg_Red,
+                ((self.lcd.screen_width) - 8 * 16) / 2,
+                self.MBASE(3),
+                "No Media",
+            )
+
+    def CompletedHoming(self):
+        self.pd.HMI_flag.home_flag = False
+        if self.checkkey == self.Last_Prepare:
+            self.checkkey = self.Prepare
+            self.select_prepare.now = self.PREPARE_CASE_HOME
+            self.index_prepare = self.MROWS
+            self.Draw_Prepare_Menu()
+        elif self.checkkey == self.Back_Main:
+            self.pd.HMI_ValueStruct.print_speed = self.pd.feedrate_percentage = 100
+            # dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z)
+            # planner.finish_and_disable()
+            self.Goto_MainMenu()
+
+    # --------------------------------------------------------------#
+    # --------------------------------------------------------------#
+
+    def icon_Print(self):
+        if self.select_page.now == 0:
+            self.lcd.draw_icon(True, self.ICON, self.icon_print_selected, 12, 51)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Print_selected, 13, 120
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 12, 51, 112, 165)
+            # self.lcd.move_screen_area(1, 1, 451, 31, 463, 57, 201)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_print, 12, 51)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Print, 13, 120
+            )
+            # self.lcd.move_screen_area(1, 1, 423, 31, 435, 57, 201)
+
+    def icon_Prepare(self):
+        if self.select_page.now == 1:
+            self.lcd.draw_icon(True, self.ICON, self.icon_prepare_selected, 126, 51)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Prepare_selected, 127, 120
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 126, 51, 226, 165)
+            # self.lcd.move_screen_area(1, 33, 451, 82, 466, 175, 201)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_prepare, 126, 51)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Prepare, 127, 120
+            )
+            # self.lcd.move_screen_area(1, 33, 423, 82, 438, 175, 201)
+
+    def icon_Control(self):
+        if self.select_page.now == 2:
+            self.lcd.draw_icon(True, self.ICON, self.icon_control_selected, 12, 178)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Control_selected, 13, 247
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 12, 178, 112, 292)
+            # self.lcd.move_screen_area(1, 85, 451, 132, 463, 48, 318)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_control, 12, 178)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Control, 13, 247
+            )
+            # self.lcd.move_screen_area(1, 85, 423, 132, 434, 48, 318)
+
+    def icon_Leveling(self, show):
+        if show:
+            self.lcd.draw_icon(True, self.ICON, self.icon_leveling_selected, 126, 178)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Leveling_selected, 126, 247
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 126, 178, 226, 292)
+            # self.lcd.move_screen_area(1, 84, 437, 120, 449, 182, 318)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_leveling, 126, 178)
+            self.lcd.draw_icon(
+                True, self.selected_language, self.icon_TEXT_Leveling, 126, 247
+            )
+            # self.lcd.move_screen_area(1, 84, 465, 120, 478, 182, 318)
+
+    def icon_StartInfo(self, show):
+        if show:
+            self.lcd.draw_icon(True, self.ICON, self.icon_Info_1, 145, 246)
+            self.lcd.draw_rectangle(0, self.color_white, 126, 178, 226, 292)
+            # self.lcd.move_screen_area(1, 132, 451, 159, 466, 186, 318)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_Info_0, 145, 246)
+            # self.lcd.move_screen_area(1, 132, 423, 159, 435, 186, 318)
+
+    def show_tune(self):
+        if self.select_print.now == 0:
+            self.lcd.draw_icon(True, self.ICON, self.icon_tune_selected, 12, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Tune_selected, 12, 225
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 12, 191, 78, 251)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_tune, 12, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Tune, 12, 225
+            )
+
+    def show_continue(self):
+        # Todo: Where is icon for continue text? replace for text if not found
+        if self.select_print.now == 1:
+            self.lcd.draw_icon(True, self.ICON, self.icon_continue_selected, 86, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Pause_selected, 86, 225
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 86, 191, 151, 251)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_continue, 86, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Pause, 86, 225
+            )
+            # self.lcd.move_screen_area(1, 1, 424, 31, 434, 121, 325)
+
+    def show_pause(self):
+        if self.select_print.now == 1:
+            self.lcd.draw_icon(True, self.ICON, self.icon_pause_selected, 86, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Pause_selected, 86, 225
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 86, 191, 151, 251)
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_pause, 86, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Pause, 86, 225
+            )
+
+    def show_stop(self):
+        if self.select_print.now == 2:
+            self.lcd.draw_icon(True, self.ICON, self.icon_stop_selected, 160, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Stop_selected, 160, 225
+            )
+            self.lcd.draw_rectangle(0, self.color_white, 160, 191, 225, 251)
+
+        else:
+            self.lcd.draw_icon(True, self.ICON, self.icon_stop, 160, 191)
+            self.lcd.draw_icon(
+                False, self.selected_language, self.icon_TEXT_Stop, 160, 225
+            )
+
+    def Item_Prepare_Move(self, row):
+        # Draw Move icon and text
+        self.draw_move_en(self.MBASE(row))
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_axis, self.icon_TEXT_move_axis
+        )
+        self.Draw_More_Icon(row)
+
+    def Item_Prepare_Disable(self, row):
+        # Draw Disable Stepper icon and text
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_close_motor, self.icon_TEXT_disable_stepper
+        )
+
+    def Item_Prepare_Home(self, row):
+        # Draw auto home icon and text
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_homing, self.icon_TEXT_auto_home
+        )
+
+    def Item_Prepare_Offset(self, row):
+        if self.pd.HAS_BED_PROBE:
+            # Draw Z-offset icon and text, iv available
+            self.Draw_Menu_Line_With_Only_Icons(
+                row, self.icon_z_offset, self.icon_TEXT_Z_Offset
+            )
+            self.lcd.draw_signed_float(
+                True,
+                self.lcd.font_8x8,
+                self.color_white,
+                self.color_background_black,
+                2,
+                3,
+                175,
+                self.MBASE(row) - 10,
+                self.pd.BABY_Z_VAR * 100,
+            )
+        else:
+            # If not, dont write text, only icon
+            self.Draw_Menu_Line(row, self.icon_set_home, "...")
+
+    def Item_Prepare_PLA(self, row):
+        # Draw preheat pla icon and text
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_preheat_pla, self.icon_TEXT_preheat_pla
+        )
+
+    def Item_Prepare_TPU(self, row):
+        # Draw preheat tpu icon and text
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_preheat_tpu, self.icon_TEXT_preheat_tpu
+        )
+
+    def Item_Prepare_Cool(self, row):
+        # Draw cooldown icon and text
+        self.Draw_Menu_Line_With_Only_Icons(
+            row, self.icon_cool, self.icon_TEXT_cooldown
+        )
+
+    # --------------------------------------------------------------#
+    # --------------------------------------------------------------#
+
+    def EachMomentUpdate(self, eventtime):
+        # variable update
+        update = self.pd.update_variable()
+        if self.last_status != self.pd.status:
+            self.last_status = self.pd.status
+            print(self.pd.status)
+            if self.pd.status == "printing":
+                self.Goto_PrintProcess()
+            elif self.pd.status in ["operational", "complete", "standby", "cancelled"]:
+                self.Goto_MainMenu()
+
+        if self.checkkey == self.PrintProcess:
+            if self.pd.HMI_flag.print_finish and not self.pd.HMI_flag.done_confirm_flag:
+                self.pd.HMI_flag.print_finish = False
+                self.pd.HMI_flag.done_confirm_flag = True
+                # show percent bar and value
+                self.Draw_Print_ProgressBar(0)
+                # show print done confirm
+                self.lcd.draw_rectangle(
+                    1,
+                    self.color_background_black,
+                    0,
+                    250,
+                    self.lcd.screen_width - 1,
+                    self.STATUS_Y,
+                )
+                self.lcd.draw_icon(
+                    True,
+                    self.selected_language,
+                    self.icon_confim_button_hovered,
+                    86,
+                    283,
+                )
+            elif self.pd.HMI_flag.pause_flag != self.pd.printingIsPaused():
+                # print status update
+                self.pd.HMI_flag.pause_flag = self.pd.printingIsPaused()
+                if self.pd.HMI_flag.pause_flag:
+                    self.show_continue()
+                else:
+                    self.show_pause()
+            self.Draw_Print_ProgressBar()
+            self.Draw_Print_ProgressElapsed()
+            self.Draw_Print_ProgressRemain()
+
+        if self.pd.HMI_flag.home_flag:
+            if self.pd.ishomed():
+                self.CompletedHoming()
+
+        if update and self.checkkey != self.MainMenu:
+            self.Draw_Status_Area(update)
+
+        return eventtime + self._update_interval
+
+    def encoder_has_data(self):
+        if self.checkkey == self.MainMenu:
+            self.HMI_MainMenu()
+        elif self.checkkey == self.SelectFile:
+            self.HMI_SelectFile()
+        elif self.checkkey == self.Prepare:
+            self.HMI_Prepare()
+        elif self.checkkey == self.Control:
+            self.HMI_Control()
+        elif self.checkkey == self.PrintProcess:
+            self.HMI_Printing()
+        elif self.checkkey == self.Print_window:
+            self.HMI_PauseOrStop()
+        elif self.checkkey == self.AxisMove:
+            self.HMI_AxisMove()
+        elif self.checkkey == self.TemperatureID:
+            self.HMI_Temperature()
+        elif self.checkkey == self.Motion:
+            self.HMI_Motion()
+        elif self.checkkey == self.Info:
+            self.HMI_Info()
+        elif self.checkkey == self.Tune:
+            self.HMI_Tune()
+        elif self.checkkey == self.PLAPreheat:
+            self.HMI_PLAPreheatSetting()
+        elif self.checkkey == self.TPUPreheat:
+            self.HMI_TPUPreheatSetting()
+        elif self.checkkey == self.MaxSpeed:
+            self.HMI_MaxSpeed()
+        elif self.checkkey == self.MaxAcceleration:
+            self.HMI_MaxAcceleration()
+        elif self.checkkey == self.MaxJerk:
+            self.HMI_MaxJerk()
+        elif self.checkkey == self.Step:
+            self.HMI_Step()
+        elif self.checkkey == self.Move_X:
+            self.HMI_Move_X()
+        elif self.checkkey == self.Move_Y:
+            self.HMI_Move_Y()
+        elif self.checkkey == self.Move_Z:
+            self.HMI_Move_Z()
+        elif self.checkkey == self.Extruder:
+            self.HMI_Move_E()
+        elif self.checkkey == self.ETemp:
+            self.HMI_ETemp()
+        elif self.checkkey == self.Homeoffset:
+            self.HMI_Zoffset()
+        elif self.checkkey == self.BedTemp:
+            self.HMI_BedTemp()
+        # elif self.checkkey == self.FanSpeed:
+        #     self.HMI_FanSpeed()
+        elif self.checkkey == self.PrintSpeed:
+            self.HMI_PrintSpeed()
+        elif self.checkkey == self.MaxSpeed_value:
+            self.HMI_MaxFeedspeedXYZE()
+        elif self.checkkey == self.MaxAcceleration_value:
+            self.HMI_MaxAccelerationXYZE()
+        elif self.checkkey == self.MaxJerk_value:
+            self.HMI_MaxJerkXYZE()
+        elif self.checkkey == self.Step_value:
+            self.HMI_StepXYZE()
+        elif self.checkkey == self.FeatureNotAvailable:
+            self.HMI_FeatureNotAvailable()
+
+    def log(self, msg, *args, **kwargs):
+        if self._logging:
+            logging.info("E3V3SE Display: " + str(msg))
+
+    def error(self, msg, *args, **kwargs):
+        logging.error("E3V3SE Display: " + str(msg))
+    
+def load_config(config):
+    return E3v3seDisplay(config)
+
diff --git a/klippy/extras/filter.py b/klippy/extras/filter.py
new file mode 100644
index 000000000..ad95dd3ab
--- /dev/null
+++ b/klippy/extras/filter.py
@@ -0,0 +1,125 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from logging import Filter
+from os import remove
+from time import time
+import mcu
+import math
+
+
+class RCTFilter:
+    def __init__(self):
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = []
+        if len(vals) < 3:
+            return vals
+        for i in range(len(vals) - 2):   
+            tmp = [math.fabs(vals[i]), math.fabs(vals[i + 1]), math.fabs(vals[i + 2])]
+            index = tmp.index(min(tmp))
+            out_vals.append(vals[index + i])
+        out_vals.append(vals[-2])
+        out_vals.append(vals[-1])
+        return out_vals
+
+
+class RCHFilter:
+    def __init__(self, cut_frq_hz, acq_frq_hz):
+        self.cut_frq_hz = cut_frq_hz
+        self.acq_frq_hz = acq_frq_hz
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [0]
+        rc = 1. / 2. / math.pi / self.cut_frq_hz
+        coff = rc / (rc + 1. / self.acq_frq_hz)
+        for i in range(1, len(vals)):
+            out_vals.append((vals[i] - vals[i - 1] + out_vals[-1]) * coff)
+        return out_vals
+
+
+class RCLFilter:
+    def __init__(self, k1_new):
+        self.k1_new = k1_new
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [vals[0]]
+        for i in range(1, len(vals)):
+            out_vals.append(out_vals[-1] * (1 - self.k1_new) + vals[i] * self.k1_new)
+        return out_vals
+
+
+class Filter:
+    def __init__(self, config):
+        self.hft_hz = config.getfloat('hft_hz', default=5, minval=0.1, maxval=10.)
+        self.lft_k1 = config.getfloat('lft_k1', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_oft = config.getfloat('lft_k1_oft', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_cal = config.getfloat('lft_k1_cal', default=0.8, minval=0., maxval=1.)
+        pass
+    
+    def get_tft(self):
+        return RCTFilter()
+
+    def get_lft(self, k1):
+        return RCLFilter(k1)
+
+    def get_hft(self, cut_hz, acq_hz):
+        return RCHFilter(cut_frq_hz=cut_hz, acq_frq_hz=acq_hz)
+
+    def cal_offset_by_vals(self, s_count, new_valss, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        lft = RCLFilter(lft_k1)
+        for i in range(s_count):
+            tmp_vals[i] = tft.ftr_val(new_valss[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+    def cal_filter_by_vals(self, s_count, now_valss, hft_hz, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        hft = RCHFilter(hft_hz, 80)
+        lft = RCLFilter(lft_k1)
+        for i in range(0, s_count):
+            tmp_vals[i] = tft.ftr_val(now_valss[i])
+            tmp_vals[i] = hft.ftr_val(tmp_vals[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+def load_config(config):
+    return Filter(config)
\ No newline at end of file
diff --git a/klippy/extras/hx711s.py b/klippy/extras/hx711s.py
new file mode 100644
index 000000000..d5c946bb3
--- /dev/null
+++ b/klippy/extras/hx711s.py
@@ -0,0 +1,207 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from os import remove
+import time
+import mcu
+import math
+
+class HX711S:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object("gcode")
+        self.s_count = config.getint('count', 1, 1, 4)
+        self.base_avgs = [0, 0, 0, 0]
+        self.del_dirty = False
+        self.index_dirty = 0
+        self.start_tick = 0
+        self.need_wait = False
+        self.s_clk_pin = []
+        self.s_sdo_pin = []
+        self.all_params = []
+        self.all_vals = [[], [], [], []]
+        for i in range(self.s_count):
+            self.s_clk_pin.append(config.get('sensor%d_clk_pin' % i, None if i == 0 else self.s_clk_pin[i - 1]))
+            self.s_sdo_pin.append(config.get('sensor%d_sdo_pin' % i, None if i == 0 else self.s_sdo_pin[i - 1]))
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu', 'mcu'))
+        self.oid = self.mcu.create_oid()
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_hx711s, "debug_hx711s", self.oid)
+        self.mcu.register_response(self._handle_result_hx711s, "result_hx711s", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode.register_command('READ_HX711', self.cmd_READ_HX711, desc=self.cmd_READ_HX711_help)
+        self.pi_count = int(0)
+        self.show_msg = False
+        self.filter = None 
+        self.query_cmd = None
+        self.mcu_freq = 72000000
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_hx711s oid=%d hx711_count=%d" % (self.oid, self.s_count))
+        pins = self.printer.lookup_object("pins") 
+        for i in range(self.s_count):
+            clk_pin_params = pins.lookup_pin(self.s_clk_pin[i])
+            sdo_pin_params = pins.lookup_pin(self.s_sdo_pin[i])
+            self.mcu.add_config_cmd("add_hx711s oid=%d index=%d clk_pin=%s sdo_pin=%s" % (self.oid, i, clk_pin_params['pin'], sdo_pin_params['pin']))
+        # self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu is_ck_con=%c", cq=None)
+        self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu", cq=None)
+        self.filter = self.printer.lookup_object('filter')
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')
+        pass
+
+    def _handle_mcu_identify(self):
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        #     "heart_beat_hx711s oid=%c",
+        #     "heart_beat_hx711s_result oid=%c",
+        #     oid=self.oid, cq=None)
+        pass
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _handle_debug_hx711s(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_result_hx711s(self, params):
+        while self.need_wait:
+            self.delay_s(0.001)
+        self.start_tick = self.start_tick if len(self.all_params) != 0 else params['nt']
+        if self.del_dirty and (params['vd'] != 0 or params['it'] > 20) and self.index_dirty == 0:
+            self.index_dirty = 1
+            return
+        self.index_dirty -= 1 if self.index_dirty == 1 else 0
+        self.all_params.append(params)
+        for i in range(self.s_count):
+            self.all_vals[i].append(params['v%d' % i] - self.base_avgs[i])
+        if self.show_msg:
+            self.gcode.respond_info('Hx711 Val=' + str(params))
+        if len(self.all_params) > self.pi_count:
+            del self.all_params[0]
+            for i in range(self.s_count):
+                del self.all_vals[i][0]
+        pass
+
+    def query_start(self, pi_count, cycle_count, del_dirty=False, show_msg=False, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if cycle_count != 0:
+            self.pi_count = pi_count
+            self.all_params = []
+            self.all_vals = [[], [], [], []]
+            self.show_msg = show_msg
+            self.del_dirty = del_dirty
+            self.index_dirty = 0
+        # self.query_cmd.send([self.oid, cycle_count, 1 if is_ck_con else 0])
+        self.query_cmd.send([self.oid, cycle_count])
+        pass
+
+    def get_params(self):
+        self.need_wait = True
+        tmps = [x for x in self.all_params]
+        self.need_wait = False
+        return tmps, self.start_tick
+
+    def get_vals(self):
+        self.need_wait = True
+        tmps = [[], [], [], []]
+        for i in range(self.s_count):
+            tmps[i] = [x for x in self.all_vals[i]]
+        self.need_wait = False
+        return tmps
+
+    def delay_s(self, delay_s):
+        toolhead = self.printer.lookup_object("toolhead")
+        reactor = self.printer.get_reactor()
+        eventtime = reactor.monotonic()
+        if not self.printer.is_shutdown():
+            toolhead.get_last_move_time()
+            eventtime = reactor.pause(eventtime + delay_s)
+            pass
+
+    def send_heart_beat(self):
+        # if time.time() - self.last_send_heart > 0.1:
+        #     self.send_heart_beat_cmd.send([self.oid])
+        #     self.last_send_heart = time.time()
+        pass
+
+    def read_base(self, cnt, max_hold, reset_zero=True):
+        avgs = [0, 0, 0, 0]
+        rvs = [[], [], [], []]
+        for i in range(3):
+            self.base_avgs = [0, 0, 0, 0]
+            avgs = [0, 0, 0, 0]
+            self.query_start(cnt, cnt + 5, del_dirty=True, show_msg=False)
+            t_last = time.time()
+            while not (self.is_shutdown or self.is_timeout) and len(self.get_vals()[0]) < cnt and (time.time() - t_last) < cnt * 0.010 * 15:
+                self.delay_s(0.010)
+                pass
+            vals = self.get_vals()
+            if len(vals[0]) < cnt:
+                raise self.printer.command_error("""{"code":"key503", "msg":"z-Touch::read_base: Can not read z-Touch data."}""")
+                
+            for j in range(self.s_count):
+                del vals[j][0:int(len(vals[j]) / 2)]
+            for j in range(self.s_count):
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+            rvs = [[], [], [], []]
+            tf = self.filter.get_tft()
+            lf = self.filter.get_lft(0.5)
+            for j in range(self.s_count):
+                vals[j] = tf.ftr_val(vals[j])
+                vals[j] = lf.ftr_val(vals[j])
+                rvs[j].append(min(vals[j]))
+                rvs[j].append(sum(vals[j]) / len(vals[j]))
+                rvs[j].append(max(vals[j]))
+                avgs[j] = sum(vals[j]) / len(vals[j])
+                self.printer.lookup_object('prtouch').pnt_msg('READ_BASE ch=%d min=%.2f avg=%.2f max=%.2f' % (j, rvs[j][-3], avgs[j], rvs[j][-1]))
+            if reset_zero:
+                self.base_avgs = avgs
+
+            sum_max = 0
+            for j in range(self.s_count):
+                sum_max += math.fabs(rvs[j][2] - rvs[j][0])
+            if sum_max < max_hold * 2:
+                break
+        return avgs, rvs
+
+    cmd_READ_HX711_help = "Read hx711s vals"
+
+    def cmd_READ_HX711(self, gcmd):
+        cnt = gcmd.get_int('C', 1, minval=1, maxval=9999) 
+        self.query_start(cnt, cnt, False, False, False)
+        self.delay_s(1.)
+        self.base_avgs = [0, 0, 0, 0]
+        vals = self.get_vals()
+        for i in range(self.s_count):
+            self.gcode.respond_info('CH%d=' % i)
+            sv = '['
+            for j in range(len(vals[i])):
+                sv += '%.2f, ' % vals[i][j]
+            self.gcode.respond_info(sv + ']')
+        self.read_base(40, 500000)
+        pass
+
+
+def load_config(config):
+    return HX711S(config)
diff --git a/klippy/extras/printerInterface.py b/klippy/extras/printerInterface.py
new file mode 100644
index 000000000..bd12d08d3
--- /dev/null
+++ b/klippy/extras/printerInterface.py
@@ -0,0 +1,410 @@
+"""
+Important: This file is imported from the DWIN_T5UIC1_LCD
+repository available on (https://github.com/odwdinc/DWIN_T5UIC1_LCD)
+with no to minimal changes. All credits go to the original author.
+"""
+import logging
+
+
+class xyze_t:
+    x = 0.0
+    y = 0.0
+    z = 0.0
+    e = 0.0
+    home_x = False
+    home_y = False
+    home_z = False
+
+    def homing(self):
+        self.home_x = False
+        self.home_y = False
+        self.home_z = False
+
+
+class AxisEnum:
+    X_AXIS = 0
+    A_AXIS = 0
+    Y_AXIS = 1
+    B_AXIS = 1
+    Z_AXIS = 2
+    C_AXIS = 2
+    E_AXIS = 3
+    X_HEAD = 4
+    Y_HEAD = 5
+    Z_HEAD = 6
+    E0_AXIS = 3
+    E1_AXIS = 4
+    E2_AXIS = 5
+    E3_AXIS = 6
+    E4_AXIS = 7
+    E5_AXIS = 8
+    E6_AXIS = 9
+    E7_AXIS = 10
+    ALL_AXES = 0xFE
+    NO_AXIS = 0xFF
+
+
+class HMI_value_t:
+    E_Temp = 0
+    Bed_Temp = 0
+    Fan_speed = 0
+    print_speed = 100
+    Max_Feedspeed = 0.0
+    Max_Acceleration = 0.0
+    Max_Jerk = 0.0
+    Max_Step = 0.0
+    Move_X_scale = 0.0
+    Move_Y_scale = 0.0
+    Move_Z_scale = 0.0
+    Move_E_scale = 0.0
+    offset_value = 0.0
+    show_mode = 0  # -1: Temperature control    0: Printing temperature
+
+
+class HMI_Flag_t:
+    language = 0
+    pause_flag = False
+    pause_action = False
+    print_finish = False
+    done_confirm_flag = False
+    select_flag = False
+    home_flag = False
+    heat_flag = False  # 0: heating done  1: during heating
+    ETempTooLow_flag = False
+    leveling_offset_flag = False
+    feedspeed_axis = AxisEnum()
+    acc_axis = AxisEnum()
+    jerk_axis = AxisEnum()
+    step_axis = AxisEnum()
+
+
+class material_preset_t:
+    def __init__(self, name, hotend_temp, bed_temp, fan_speed=100):
+        self.name = name
+        self.hotend_temp = hotend_temp
+        self.bed_temp = bed_temp
+        self.fan_speed = fan_speed
+
+class PrinterData:
+    event_loop = None
+    HAS_HOTEND = True
+    HOTENDS = 1
+    HAS_HEATED_BED = True
+    HAS_FAN = False
+    HAS_ZOFFSET_ITEM = True
+    HAS_ONESTEP_LEVELING = True
+    HAS_PREHEAT = True
+    HAS_BED_PROBE = True
+    PREVENT_COLD_EXTRUSION = True
+    EXTRUDE_MINTEMP = 170
+    EXTRUDE_MAXLENGTH = 200
+
+    HEATER_0_MAXTEMP = 275
+    HEATER_0_MINTEMP = 5
+    HOTEND_OVERSHOOT = 15
+
+    MAX_E_TEMP = HEATER_0_MAXTEMP - (HOTEND_OVERSHOOT)
+    MIN_E_TEMP = HEATER_0_MINTEMP
+
+    BED_OVERSHOOT = 10
+    BED_MAXTEMP = 150
+    BED_MINTEMP = 5
+
+    BED_MAX_TARGET = BED_MAXTEMP - (BED_OVERSHOOT)
+    MIN_BED_TEMP = BED_MINTEMP
+
+    X_MIN_POS = 0.0
+    Y_MIN_POS = 0.0
+    Z_MIN_POS = 0.0
+    Z_MAX_POS = 200
+
+    Z_PROBE_OFFSET_RANGE_MIN = -20
+    Z_PROBE_OFFSET_RANGE_MAX = 20
+
+
+    BABY_Z_VAR = 0
+    feedrate_percentage = 100
+    temphot = 0
+    tempbed = 0
+
+    HMI_ValueStruct = HMI_value_t()
+    HMI_flag = HMI_Flag_t()
+
+    current_position = xyze_t()
+
+    thermalManager = {
+        "temp_bed": {"celsius": 20, "target": 120},
+        "temp_hotend": [{"celsius": 20, "target": 120}],
+        "fan_speed": [100],
+    }
+
+    material_preset = [
+        material_preset_t("PLA", 200, 60),
+        material_preset_t("ABS", 210, 100),
+    ]
+    files = None
+    MACHINE_SIZE = "220x220x250"
+    SHORT_BUILD_VERSION = "1.00"
+    CORP_WEBSITE_E = "www.klipper3d.org"
+
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.config = config
+        self.mutex = self.printer.get_reactor().mutex()
+        self.name = config.get_name()
+        self.reactor = self.printer.get_reactor()
+        self._logging = config.getboolean("logging", False)
+        self.gcode = self.printer.lookup_object("gcode")
+        self.fl = []
+        self.status = None
+ 
+
+    def get_additional_values(self):
+        toolhead = self.printer.lookup_object(
+            "toolhead").get_status(self.reactor.monotonic())
+        if toolhead:
+            if "position" in toolhead:
+                self.current_position.x = toolhead["position"][0]
+                self.current_position.y = toolhead["position"][1]
+                self.current_position.z = toolhead["position"][2]
+                self.current_position.e = toolhead["position"][3]
+            if "homed_axes" in toolhead:
+                if "x" in toolhead["homed_axes"]:
+                    self.current_position.home_x = True
+                if "y" in toolhead["homed_axes"]:
+                    self.current_position.home_y = True
+                if "z" in toolhead["homed_axes"]:
+                    self.current_position.home_z = True
+            if "axis_maximum" in toolhead:
+                volume = toolhead["axis_maximum"]  # [x,y,z,w]
+                self.MACHINE_SIZE = "{}x{}x{}".format(
+                    int(volume[0]), int(volume[1]), int(volume[2])
+                )
+                self.X_MAX_POS = int(volume[0])
+                self.Y_MAX_POS = int(volume[1])
+
+        configfile = self.printer.lookup_object(
+            "configfile").get_status(self.reactor.monotonic())
+        if "config" in configfile:
+            if "bltouch" in configfile["config"]:
+                if "z_offset" in configfile["config"]["bltouch"]:
+                    if configfile["config"]["bltouch"]["z_offset"]:
+                        self.BABY_Z_VAR = float(
+                            configfile["config"]["bltouch"][
+                                "z_offset"
+                            ]
+                        )
+    
+    def ishomed(self):
+        if (
+            self.current_position.home_x
+            and self.current_position.home_y
+            and self.current_position.home_z
+        ):
+            return True
+        else:
+            self.get_additional_values()
+            return False
+
+    def offset_z(self, new_offset):
+        self.log('new z offset:', new_offset)
+        self.BABY_Z_VAR = new_offset
+        self.sendGCode("ACCEPT")
+
+    def postREST(self, path, json):
+        self.log("postREST called")
+
+
+    def GetFiles(self, refresh=False):
+        sdcard = self.printer.lookup_object('virtual_sdcard')
+        files = sdcard.get_file_list(True)
+        self.fl = []
+        self.names = []
+        for file, _ in files:
+            self.fl.append(file)
+            self.names.append(file.split('/')[-1])
+        return self.names
+
+    def update_variable(self):
+        gcm = self.printer.lookup_object(
+            "gcode_move").get_status(self.reactor.monotonic())
+        z_offset = gcm["homing_origin"][2]  # z offset
+        flow_rate = gcm["extrude_factor"] * 100  # flow rate percent
+        self.absolute_moves = gcm["absolute_coordinates"]  # absolute or relative
+        self.absolute_extrude = gcm["absolute_extrude"]  # absolute or relative
+        speed = gcm["speed"]  # current speed in mm/s
+        print_speed = gcm["speed_factor"] * 100  # print speed percent
+        bed = self.printer.lookup_object(
+            "heater_bed").get_status(self.reactor.monotonic())
+        extruder = self.printer.lookup_object(
+            "extruder").get_status(self.reactor.monotonic())
+        fan = self.printer.lookup_object(
+            "fan").get_status(self.reactor.monotonic())
+        Update = False
+        try:
+            if self.thermalManager["temp_bed"]["celsius"] != int(bed["temperature"]):
+                self.thermalManager["temp_bed"]["celsius"] = int(bed["temperature"])
+                Update = True
+            if self.thermalManager["temp_bed"]["target"] != int(bed["target"]):
+                self.thermalManager["temp_bed"]["target"] = int(bed["target"])
+                Update = True
+            if self.thermalManager["temp_hotend"][0]["celsius"] != int(
+                extruder["temperature"]
+            ):
+                self.thermalManager["temp_hotend"][0]["celsius"] = int(
+                    extruder["temperature"]
+                )
+                Update = True
+            if self.thermalManager["temp_hotend"][0]["target"] != int(
+                extruder["target"]
+            ):
+                self.thermalManager["temp_hotend"][0]["target"] = int(
+                    extruder["target"]
+                )
+                Update = True
+            if self.thermalManager["fan_speed"][0] != int(fan["speed"] * 100):
+                self.thermalManager["fan_speed"][0] = int(fan["speed"] * 100)
+                Update = True
+            if self.BABY_Z_VAR != z_offset:
+                self.BABY_Z_VAR = z_offset
+                self.HMI_ValueStruct.offset_value = z_offset * 100
+                Update = True
+        except:
+            pass  # missing key, shouldn't happen, fixes misses on conditionals \_()_/
+        self.job_Info = self.printer.lookup_object(
+            "print_stats").get_status(self.reactor.monotonic())
+        if self.job_Info:
+            self.file_name = self.job_Info["filename"]
+            self.status = self.job_Info["state"]
+            self.HMI_flag.print_finish = self.getPercent() == 100.0
+        return Update
+
+    def printingIsPaused(self):
+        return (
+            self.job_Info["state"] == "paused"
+            or self.job_Info["state"] == "pausing"
+        )
+
+    def getPercent(self):
+        self.virtual_sdcard_stats = self.printer.lookup_object(
+            "virtual_sdcard").get_status(self.reactor.monotonic())
+        if self.virtual_sdcard_stats:
+            if self.virtual_sdcard_stats["is_active"]:
+                return self.virtual_sdcard_stats["progress"] * 100
+        return 0
+
+    def duration(self):
+        self.virtual_sdcard_stats = self.printer.lookup_object(
+            "virtual_sdcard").get_status(self.reactor.monotonic())
+        if self.virtual_sdcard_stats:
+            if self.virtual_sdcard_stats["is_active"]:
+                return self.job_Info["print_duration"]
+        return 0
+
+    def remain(self):
+        percent = self.getPercent()
+        duration = self.duration()
+        if percent:
+            total = duration / (percent / 100)
+            return total - duration
+        return 0
+
+    def home(self, homeZ=False):  # fixed using gcode
+        script = "G28 X Y"
+        if homeZ:
+            script += " Z"
+        self.sendGCode(script)
+
+    def moveRelative(self, axis, distance, speed):
+        self.sendGCode(
+            "%s \n%s %s%s F%s%s"
+            % (
+                "G91",
+                "G1",
+                axis,
+                distance,
+                speed,
+                "\nG90" if self.absolute_moves else "",
+            )
+        )
+
+    def sendGCode(self, Gcode):
+        gcode = self.printer.lookup_object('gcode')
+        gcode._process_commands([Gcode])
+
+    def disable_all_heaters(self):
+        self.setExtTemp(0)
+        self.setBedTemp(0)
+
+    def zero_fan_speeds(self):
+        pass
+
+    def preheat(self, profile):
+        if profile == "PLA":
+            self.preHeat(
+                self.material_preset[0].bed_temp, self.material_preset[0].hotend_temp
+            )
+        elif profile == "ABS":
+            self.preHeat(
+                self.material_preset[1].bed_temp, self.material_preset[1].hotend_temp
+            )
+
+    def preHeat(self, bedtemp, exttemp, toolnum=0):
+        # these work but invoke a wait which hangs the screen until they finish.
+        # 		self.sendGCode('M140 S%s\nM190 S%s' % (bedtemp, bedtemp))
+        # 		self.sendGCode('M104 T%s S%s\nM109 T%s S%s' % (toolnum, exttemp, toolnum, exttemp))
+        self.setBedTemp(bedtemp)
+        self.setExtTemp(exttemp)
+
+    
+    def openAndPrintFile(self, filenum):
+        self.sendGCode('SDCARD_PRINT_FILE FILENAME="{}"'.format(self.fl[filenum]))
+
+    def sendGCode(self, Gcode):
+        self.gcode._process_commands([Gcode])
+
+    def probe_calibrate(self):
+        self.sendGCode('G28') # home the printer
+        self.sendGCode('PRTOUCH_PROBE_OFFSET CLEAR_NOZZLE=0 APPLY_Z_ADJUST=1') # use the prtouch to find the z offset and apply it
+
+    def resume_job(self):
+        self.sendGCode('RESUME') # resume the print
+
+    def pause_job(self):
+        self.sendGCode('PAUSE') # pause the print
+
+    def cancel_job(self):
+        self.sendGCode('CANCEL_PRINT') # cancel the print
+
+    def set_feedrate(self, value):
+        self.sendGCode('M220 S' + str(value)) # set the feedrate through the M220 gcode command
+
+    def moveAbsolute(self, axis, pos, feedrate):
+        self.sendGCode('M82') # change to absolute positioning
+        self.sendGCode('G1 {}{} F{}'.format(axis, str(pos), str(feedrate))) # move the specified axis at the set feedrate
+
+    def save_settings(self):
+        self.sendGCode('SAVE_CONFIG') # save the current configuration changes
+
+    def setExtTemp(self, target, toolnum=0):
+        self.sendGCode("M104 T%s S%s" % (toolnum, str(target)))
+
+    def setExtTemp(self, target):
+        self.sendGCode('M104 S' + str(target))
+
+    def setZOffset(self, offset):
+        self.sendGCode('SET_GCODE_OFFSET Z={} MOVE=1'.format(str(offset)))
+
+    def add_mm(self, axis, zoffset):
+        self.sendGCode('TESTZ Z=' + str(zoffset))
+
+    def log(self, msg, *args, **kwargs):
+        if self._logging:
+            logging.info("PrinterData: " + str(msg))
+
+    def error(self, msg, *args, **kwargs):
+        logging.error("PrinterData: " + str(msg))
+
+
+def load_config(config):
+    return PrinterData(config)
diff --git a/klippy/extras/prtouch.py b/klippy/extras/prtouch.py
new file mode 100644
index 000000000..c4ab1aa51
--- /dev/null
+++ b/klippy/extras/prtouch.py
@@ -0,0 +1,463 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2022-12-09  CC <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
+import math
+import random
+import mcu
+import time
+
+class PRTouchCFG:
+    def __init__(self, config):
+        self.base_count = config.getint('base_count', default=40, minval=10, maxval=100)
+        self.pi_count = config.getint('pi_count', default=32, minval=16, maxval=128)
+        self.min_hold = config.getint('min_hold', default=3000, minval=100, maxval=50000)
+        self.max_hold = config.getint('max_hold', default=50000, minval=100, maxval=100000)
+        self.sensor_x = config.getfloat('sensor_x', minval=0, maxval=300)
+        self.sensor_y = config.getfloat('sensor_y', minval=0, maxval=300)
+        self.random_offset = config.getfloat('sensor_random_offset', default=5, minval=0, maxval=10)
+        self.hot_min_temp = config.getfloat('s_hot_min_temp', default=140, minval=80, maxval=200)
+        self.hot_max_temp = config.getfloat('s_hot_max_temp', default=200, minval=180, maxval=300)
+        self.bed_max_temp = config.getfloat('s_bed_max_temp', default=60, minval=45, maxval=100)
+        self.pa_clr_dis_mm = config.getint('pa_clr_dis_mm', default=5, minval=2, maxval=100)
+        self.pa_clr_down_mm = config.getfloat('pa_clr_down_mm', default=-0.1, minval=-1, maxval=1)
+        self.clr_noz_start_x = config.getfloat('clr_noz_start_x', default=0, minval=0, maxval=1000)
+        self.clr_noz_start_y = config.getfloat('clr_noz_start_y', default=0, minval=0, maxval=1000)
+        self.clr_noz_len_x = config.getfloat('clr_noz_len_x', default=0, minval=0, maxval=1000)
+        self.clr_noz_len_y = config.getfloat('clr_noz_len_y', default=0, minval=self.pa_clr_dis_mm + 5, maxval=1000)
+        self.bed_max_err = config.getint('bed_max_err', default=4, minval=2, maxval=10)
+        self.max_z = config.getsection('stepper_z').getfloat('position_max', default=300, minval=100, maxval=500)
+        self.g29_xy_speed = config.getfloat('g29_xy_speed', default=150, minval=10, maxval=1000)
+        self.g29_rdy_speed = config.getfloat('g29_rdy_speed', default=2.5, minval=0.1, maxval=10)
+        self.probe_speed = config.getfloat('probe_speed', default=2.0, minval=0.1, maxval=10)
+        self.show_msg = config.getboolean('show_msg', default=False)
+        self.check_bed_mesh_max_err = config.getfloat('check_bed_mesh_max_err', default=0.2, minval=0.01, maxval=1)
+        self.wipe_retract_distance = config.getfloat('wipe_retract_distance', default=0, minval=0, maxval=50)
+
+        self.stored_profs = config.get_prefix_sections('prtouch')
+        self.stored_profs = self.stored_profs[1] if (len(self.stored_profs) == 2) else None
+        pass
+
+
+class PRTouchVAL:
+    def __init__(self, config):
+        self.out_index = 0
+        self.out_val_mm = 0.
+        self.re_probe_cnt = 0
+        self.home_xy = None
+        pass
+
+
+class PRTouchOBJ:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.hx711s = None
+        self.pheaters = None
+        self.heater_hot = None
+        self.heater_bed = None
+        self.bed_mesh = None
+        self.mcu = None
+        self.dirzctl = None
+        self.kin = None
+        self.probe = None
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode_move = self.printer.lookup_object('gcode_move')
+        pass
+
+    def find_objs(self):
+        self.toolhead = self.printer.lookup_object('toolhead')
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.pheaters = self.printer.lookup_object('heaters')
+        self.heater_hot = self.printer.lookup_object('extruder').heater
+        self.heater_bed = self.printer.lookup_object('heater_bed').heater
+        self.bed_mesh = self.printer.lookup_object('bed_mesh')
+        self.dirzctl = self.printer.lookup_object('dirzctl')
+        self.mcu = self.hx711s.mcu
+        self.filter = self.printer.lookup_object('filter')
+        self.kin = self.toolhead.get_kinematics()
+        self.probe = self.printer.lookup_object('probe', None)
+        pass
+
+
+class PRTouchZOffsetWrapper:
+    def __init__(self, config):
+        self.cfg = PRTouchCFG(config)
+        self.val = PRTouchVAL(config)
+        self.obj = PRTouchOBJ(config)
+
+        self.obj.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.obj.gcode.register_command('PRTOUCH_PROBE_ZOFFSET', self.cmd_PRTOUCH_PROBE_ZOFFSET, desc=self.cmd_PRTOUCH_PROBE_ZOFFSET_help)
+        self.obj.gcode.register_command('NOZZLE_CLEAR', self.cmd_NOZZLE_CLEAR, desc=self.cmd_NOZZLE_CLEAR_help)
+        self.obj.gcode.register_command('PRTOUCH_ACCURACY', self.cmd_PRTOUCH_ACCURACY, desc=self.cmd_PRTOUCH_ACCURACY_help)
+        pass
+
+    def _handle_mcu_identify(self):
+        self.obj.find_objs()
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        self.val.home_xy = [(max_x - min_x) / 2 + min_x, (max_y - min_y) / 2 + min_y]
+        pass
+
+    def get_mcu(self):
+        return self.obj.mcu
+
+    def get_steppers(self):
+        return self.obj.dirzctl.steppers
+
+    def ck_sys_sta(self):
+        return not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout
+
+    def _ck_g28ed(self, is_precision=True):
+        for i in range(3):
+            if self.obj.kin.limits[i][0] > self.obj.kin.limits[i][1]:
+                self.obj.gcode.run_script_from_command('G28')
+                break
+        pass
+
+    def _move(self, pos, speed, wait=True):
+        if not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout:
+            # self.obj.toolhead.manual_move(pos, speed)
+            self.obj.gcode.run_script_from_command('G1 F%d X%.3f Y%.3f Z%.3f' % (speed * 60, pos[0], pos[1], pos[2]) if len(pos) >= 3 else 'G1 F%d X%.3f Y%.3f' % (speed * 60, pos[0], pos[1]))
+            if wait:
+                self.obj.toolhead.wait_moves()
+            pass
+
+    def _get_linear2(self, p1, p2, po, is_base_x):
+        if (math.fabs(p1[0] - p2[0]) < 0.001 and is_base_x) or (math.fabs(p1[1] - p2[1]) < 0.001 and not is_base_x):
+            return po
+        a = (p2[2] - p1[2]) / ((p2[0] - p1[0]) if is_base_x else (p2[1] - p1[1]))
+        b = p1[2] - (p1[0] if is_base_x else p1[1]) * a
+        po[2] = a * (po[0] if is_base_x else po[1]) + b
+        return po
+
+    def _pnt_tri_msg(self, index, msg,  ary):
+        if self.cfg.show_msg:
+            self.pnt_msg('TRI SUCCESS BY: ' + msg)
+            self.pnt_array('TRI CH=%d ARY=' % index, ary)
+        pass
+
+    def _check_trigger(self, arg_index, fit_vals, unfit_vals, min_hold, max_hold):
+        all_params, tick = self.obj.dirzctl.get_params()
+        if len(all_params) == 2:
+            self._pnt_tri_msg(arg_index, 'Tri by Dirzctl run over!', fit_vals)
+            return True
+        fit_vals_t = [x for x in fit_vals]
+        self.val.out_index = self.cfg.pi_count - 1
+        if len(fit_vals) >= (self.cfg.pi_count / 2) and math.fabs(fit_vals[-1]) >= max_hold and \
+                math.fabs(fit_vals[-2]) >= max_hold and math.fabs(fit_vals[-3]) >= max_hold:
+            self._pnt_tri_msg(arg_index, 'Tri by out max_hold!', fit_vals)
+            return True
+        if len(fit_vals) != self.cfg.pi_count:
+            return False           
+        for i in range(1, self.cfg.pi_count - 1):
+            if fit_vals_t[i] >= max_hold and fit_vals_t[i - 1] < (max_hold / 2) and fit_vals_t[i + 1] < (max_hold / 2):
+                fit_vals_t[i] = fit_vals_t[i - 1]
+        
+        vals_p = [x for x in fit_vals_t]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        max_val += 1 if (max_val - min_val) == 0 else 0
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+        if(self.val.out_index > 0):
+            for i in range(self.val.out_index, self.cfg.pi_count):
+                fit_vals_t[self.val.out_index] = fit_vals_t[self.val.out_index] * (self.obj.filter.lft_k1_oft / 2) + fit_vals_t[self.val.out_index - 1] * (1 - (self.obj.filter.lft_k1_oft / 2))
+        vals_p = [x for x in fit_vals_t]
+
+        if not (fit_vals_t[-1] > fit_vals_t[-2] > fit_vals_t[-3]):
+            return False
+        max_val = max(fit_vals_t[0:(self.cfg.pi_count - 3)])
+        if not ((fit_vals_t[-1] > max_val) and (fit_vals_t[-2] > max_val) and (fit_vals_t[-3] > max_val)):
+            return False
+        max_val = max(fit_vals_t)
+        min_val = min(fit_vals_t)
+        for i in range(0, self.cfg.pi_count):
+            fit_vals_t[i] = (fit_vals_t[i] - min_val) / (max_val - min_val)
+        for i in range(0, self.cfg.pi_count - 1):
+            if (fit_vals_t[-1] - fit_vals_t[i]) / ((self.cfg.pi_count - i) * 1. / self.cfg.pi_count) < 0.8:
+                return False
+        if fit_vals[-1] < min_hold or fit_vals[-2] < (min_hold / 2) or fit_vals[-3] < (min_hold / 3):
+            return False
+        self._pnt_tri_msg(arg_index, 'Tri by fit all rule!', vals_p)
+        return True
+
+    def _set_hot_temps(self, temp, fan_spd, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_hot, temp, False)
+        self.obj.gcode.run_script_from_command('M106 P0 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('M106 P1 S%d' % (fan_spd))
+        self.obj.gcode.run_script_from_command('M106 P2 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan0 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan1 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan2 VALUE=%d' % (fan_spd))
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_hot.target_temp - self.obj.heater_hot.smoothed_temp) > err and self.obj.heater_hot.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100) 
+        pass
+
+    def _set_bed_temps(self, temp, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_bed, temp, False)           
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_bed.target_temp - self.obj.heater_bed.smoothed_temp) > err and self.obj.heater_bed.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100)          
+        pass
+
+    def _calc_mean(self, positions):
+        count = float(len(positions))
+        return sum(positions) / count
+
+    def _calc_median(self, positions):
+        z_sorted = sorted(positions)
+        middle = len(positions) // 2
+        if (len(positions) & 1) == 1:
+            # odd number of samples
+            return z_sorted[middle]
+        # even number of samples
+        return self._calc_mean(z_sorted[middle-1:middle+1])
+
+    def pnt_msg(self, msg):
+        logging.info(msg)
+        if self.cfg.show_msg:
+            self.obj.gcode.respond_info(msg)
+        pass
+
+    def pnt_array(self, title, ary, lent=32):
+        logging.info('[%s] %s' , title, str(ary))
+        if self.cfg.show_msg:
+            st = title + ' ['
+            for i in range(len(ary) - lent, len(ary)):
+                st = st + "%.2f, " % (ary[i])
+            self.pnt_msg(st + ']')
+        pass
+
+    def _probe_times(self, max_times, rdy_pos, speed_mm, min_dis_mm, max_z_err, min_hold, max_hold):
+        o_mm = 0
+        rdy_pos_z = rdy_pos[2]
+        now_pos = self.obj.toolhead.get_position()
+        self._move(now_pos[:2] + [rdy_pos[2]], self.cfg.g29_rdy_speed)        
+        self._move(rdy_pos, self.cfg.g29_xy_speed)
+        for i in range(max_times):
+            o_index0, o_mm0, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            if not deal_sta and rdy_pos_z == rdy_pos[2]:
+                rdy_pos_z += 2
+                continue
+            o_index1, o_mm1, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            o_mm = (o_mm0 + o_mm1) / 2
+            if math.fabs(o_mm0 - o_mm1) <= max_z_err or not self.ck_sys_sta():
+                break
+            self.val.re_probe_cnt += 1
+            self.pnt_msg('***_probe_times must be reprobe= o_mm0=%.2f, o_mm1=%.2f' % (o_mm0, o_mm1))
+        return o_mm
+    
+    def clear_nozzle(self, hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold):
+        min_x, min_y = self.cfg.clr_noz_start_x, self.cfg.clr_noz_start_y
+        max_x, max_y = self.cfg.clr_noz_start_x + self.cfg.clr_noz_len_x, self.cfg.clr_noz_start_y + self.cfg.clr_noz_len_y
+        self._set_bed_temps(temp=bed_max_temp, wait=False)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False, err=10)
+        self._ck_g28ed(False)
+        random.seed(time.time())  
+        cur_pos = self.obj.toolhead.get_position()
+        src_pos = [min_x, min_y, self.cfg.bed_max_err + 1, cur_pos[3]]
+        end_pos = [max_x, max_y, src_pos[2], src_pos[3]]
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=True, err=10)   
+        src_pos[2] = self._probe_times(3, [src_pos[0], src_pos[1], src_pos[2]], self.cfg.probe_speed, 10, 0.2, min_hold, max_hold)
+        self._set_hot_temps(temp=hot_min_temp + 40, fan_spd=0, wait=False, err=10)
+        end_pos[2] = self._probe_times(3, [end_pos[0], end_pos[1], end_pos[2]], self.cfg.probe_speed, 10, 0.2, min_hold, max_hold)     
+        self._move(src_pos[:2] + [self.cfg.bed_max_err + 1], self.cfg.g29_xy_speed) 
+        self._move(src_pos[:2] + [src_pos[2] + 0.1], self.cfg.g29_rdy_speed) 
+        self._set_hot_temps(temp=hot_max_temp, fan_spd=0, wait=True, err=10)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False)
+        # retract filament
+        if self.cfg.wipe_retract_distance > 0:
+            self.obj.gcode.run_script_from_command('G91')
+            self.obj.gcode.run_script_from_command('G1 E-%.2f F600' % self.cfg.wipe_retract_distance)
+            self.obj.gcode.run_script_from_command('G90')
+        self._move(end_pos[:2] + [end_pos[2] + self.cfg.pa_clr_down_mm], self.cfg.probe_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=255, wait=True, err=5)
+        self._move([end_pos[0], end_pos[1] + 10, end_pos[2] + 10], self.cfg.probe_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False) 
+        self._set_bed_temps(temp=bed_max_temp, wait=True, err=5)
+
+        self._move(self.val.home_xy + [10], self.cfg.g29_xy_speed)
+        self.obj.gcode.run_script_from_command('G28 Z')
+        pass
+
+    def probe_z_offset(self, x, y):
+        self._ck_g28ed()
+        z_offset = self._probe_times(3, [x, y, self.cfg.bed_max_err + 1.], self.cfg.probe_speed, 10, self.cfg.check_bed_mesh_max_err, self.cfg.min_hold, self.cfg.max_hold)
+        return z_offset
+
+    def _cal_min_z(self, start_z, hx711_vals):
+        hx711_params, hx711_start_tick = self.obj.hx711s.get_params()
+        dirzctl_params, dirzctl_start_tick = self.obj.dirzctl.get_params()
+        if dirzctl_params is None or len(dirzctl_params) != 2:     
+            raise self.obj.printer.command_error("""{"code":"key502", "msg":"probe_by_step: Can not recv stepper-z status."}""")
+        if len(hx711_vals) < self.cfg.pi_count or len(hx711_params) < self.cfg.pi_count:
+            up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+            return up_all_cnt, up_all_cnt, False
+        del hx711_params[0:(len(hx711_params) - self.cfg.pi_count)]
+
+        vals_p = [x for x in hx711_vals]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+
+        dirzctl_params[0]['tick'] = (dirzctl_params[0]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[1]['tick'] = ((4294967296 if dirzctl_params[1]['tick'] < dirzctl_start_tick else 0) + dirzctl_params[1]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[0]['z'] = start_z
+        dirzctl_params[1]['z'] = start_z - (dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1) * (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base)
+        tick_p = ((4294967296 if hx711_params[self.val.out_index]['nt'] < hx711_start_tick else 0) + hx711_params[self.val.out_index]['nt'] - hx711_start_tick) / self.obj.hx711s.mcu_freq
+        self.val.out_val_mm = self._get_linear2([dirzctl_params[0]['tick'], 0, dirzctl_params[0]['z']], [dirzctl_params[1]['tick'], 0, dirzctl_params[1]['z']], [tick_p, 0, 0], True)[2]
+        self.pnt_msg('call_min_z, re_probe_cnt=%d, out_index=%d, out_val_mm=%.2f' % (self.val.re_probe_cnt, self.val.out_index, self.val.out_val_mm))
+        up_min_cnt = int((self.val.out_val_mm - dirzctl_params[1]['z']) / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+        limt_up_cnt = int(10 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_min_cnt = up_min_cnt if up_min_cnt < limt_up_cnt else limt_up_cnt  
+        up_all_cnt = up_all_cnt if up_all_cnt < limt_up_cnt else limt_up_cnt
+        return (up_min_cnt if up_min_cnt >= 0 else 0), up_all_cnt, True
+
+    def probe_by_step(self, rdy_pos, speed_mm, min_dis_mm, min_hold, max_hold, up_after=True):
+        self.obj.hx711s.read_base(int(self.cfg.base_count / 2), max_hold)
+        step_cnt = int(min_dis_mm / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        step_us = int(((min_dis_mm / speed_mm) * 1000 * 1000) / step_cnt)
+        self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(65535), del_dirty=True, show_msg=False, is_ck_con=True)        
+        self.obj.dirzctl.check_and_run(0, int(step_us), int(step_cnt), wait_finish=False, is_ck_con=True)
+        self.obj.hx711s.delay_s(0.015)
+        self.pnt_msg('*********************************************************')
+        self.pnt_msg('PROBE_BY_STEP x=%.2f y=%.2f z=%.2f speed_mm=%.2f step_us=%d step_cnt=%d' % (rdy_pos[0], rdy_pos[1], rdy_pos[2], speed_mm, step_us, step_cnt))
+        while self.ck_sys_sta():
+            self.obj.hx711s.send_heart_beat()
+            self.obj.dirzctl.send_heart_beat()
+            all_valss = self.obj.hx711s.get_vals()
+            if all_valss is None or len(all_valss[0]) == 0:
+                self.obj.hx711s.delay_s(0.005)
+                continue
+            unfit_vals, tmp_unfit_vals = self.obj.filter.cal_offset_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.lft_k1_oft, self.cfg.pi_count)
+            fit_vals, tmp_fit_vals = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1, self.cfg.pi_count)
+            
+            for i in range(self.obj.hx711s.s_count):
+                if not self._check_trigger(i, tmp_fit_vals[i], tmp_unfit_vals[i], min_hold, max_hold):
+                    continue
+                self.obj.dirzctl.check_and_run(0, 0, 0, wait_finish=False)
+                self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(0), del_dirty=False, show_msg=False)
+                self.obj.hx711s.delay_s(0.015)
+                for j in range(int(self.obj.hx711s.s_count)):
+                    self.pnt_array('TRIGGER_USE_CH=%d, FIT_VALS=' % (j), tmp_fit_vals[j], 16)
+                self.obj.hx711s.delay_s(0.2)
+                all_valss = self.obj.hx711s.get_vals()
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), all_valss[i])
+                hx711_vals, tmp_hx711_vs = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1_cal, self.cfg.pi_count)
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), tmp_hx711_vs[i])
+                up_min_cnt, up_all_cnt, deal_sta = self._cal_min_z(rdy_pos[2], tmp_hx711_vs[i])
+                if up_after:
+                    self.obj.dirzctl.check_and_run(1, int(step_us / 2), int(up_all_cnt))
+                return self.val.out_index, self.val.out_val_mm, deal_sta
+            self.obj.hx711s.delay_s(0.005)
+        return self.val.out_index, self.val.out_val_mm, True
+
+    cmd_NOZZLE_CLEAR_help = "Clear the nozzle on bed."
+    def cmd_NOZZLE_CLEAR(self, gcmd):
+        hot_min_temp = gcmd.get_float('HOT_MIN_TEMP', self.cfg.hot_min_temp)
+        hot_max_temp = gcmd.get_float('HOT_MAX_TEMP', self.cfg.hot_max_temp)
+        bed_max_temp = gcmd.get_float('BED_MAX_TEMP', self.cfg.bed_max_temp)
+        min_hold = gcmd.get_int('MIN_HOLD', self.cfg.min_hold)
+        max_hold = gcmd.get_int('MAX_HOLD', self.cfg.max_hold)
+        self.clear_nozzle(hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold)
+
+    cmd_PRTOUCH_PROBE_ZOFFSET_help = "Probe the z-offset"
+    def cmd_PRTOUCH_PROBE_ZOFFSET(self, gcmd):
+        self._ck_g28ed()
+
+        homing_origin = self.obj.gcode_move.get_status()['homing_origin']
+        self.pnt_array('homing_origin: ', homing_origin, len(homing_origin))
+        start_z_offset = self.obj.probe.get_offsets()[2]
+        self.pnt_msg('Start z_offset: %.3f' % start_z_offset)
+
+        if gcmd.get_int('CLEAR_NOZZLE', 0) == 1:
+            self.clear_nozzle(self.cfg.hot_min_temp, self.cfg.hot_max_temp, self.cfg.bed_max_temp,
+                            self.cfg.min_hold, self.cfg.max_hold)
+
+        x = self.cfg.sensor_x + random.uniform(-self.cfg.random_offset, self.cfg.random_offset)
+        y = self.cfg.sensor_y + random.uniform(-self.cfg.random_offset, self.cfg.random_offset)
+        probe_x_offset, probe_y_offset = self.obj.probe.get_offsets()[:2]
+        probe_x = x - probe_x_offset
+        probe_y = y - probe_y_offset
+        self.pnt_msg("Checking z-position of probe (%.2f, %.2f)" % (probe_x, probe_y))
+        self._move([probe_x, probe_y, self.cfg.bed_max_err + 1.], self.cfg.g29_xy_speed)
+        probe_gcmd = self.obj.gcode.create_gcode_command("PROBE", "PROBE", {'SAMPLES': '2'})
+        z_probe = self.obj.probe.run_probe(probe_gcmd)
+        self.pnt_msg('Probe at sensor: %.3f' % z_probe[2])
+
+        nozzle_z_offset = self.probe_z_offset(x, y)
+        self.pnt_msg('Nozzle z_offset: %.3f' % nozzle_z_offset)
+
+        z_offset = nozzle_z_offset - z_probe[2]
+        self.pnt_msg('Calculated z_offset: %.3f' % z_offset)
+
+        z_adjust = z_offset + start_z_offset
+        self.pnt_msg('z_adjust: %.3f' % z_adjust)
+        if gcmd.get_int('APPLY_Z_ADJUST', 0) == 1:
+            self.obj.gcode.run_script_from_command('SET_GCODE_OFFSET Z_ADJUST=%f MOVE=1' % (z_adjust))
+
+        z_probe[2] = homing_origin[2] + z_adjust - start_z_offset
+        self.obj.probe.probe_calibrate_finalize(z_probe)
+
+    cmd_PRTOUCH_ACCURACY_help = "Probe Z-height accuracy at sensoor position"
+    def cmd_PRTOUCH_ACCURACY(self, gcmd):
+        self._ck_g28ed()
+        speed = gcmd.get_float("PROBE_SPEED", self.cfg.probe_speed, above=0.)
+        sample_count = gcmd.get_int("SAMPLES", 10, minval=1)
+        gcmd.respond_info("PRTOUCH_ACCURACY at X:%.3f Y:%.3f"
+                          " (samples=%d speed=%.1f)\n"
+                          % (self.cfg.sensor_x, self.cfg.sensor_y,
+                             sample_count, speed))
+        sensor_pos = [self.cfg.sensor_x, self.cfg.sensor_y, self.cfg.bed_max_err]
+        # Move to sensor location
+        self._move(sensor_pos, self.cfg.g29_xy_speed)
+        # Probe bed sample_count times
+        positions = []
+        while len(positions) < sample_count:
+            # Probe position
+            _index1, pos, _sta = self.probe_by_step(sensor_pos, speed, 10, self.cfg.min_hold, self.cfg.max_hold, True)
+            positions.append(pos)
+            gcmd.respond_info(
+                "probe #%d at (%.3f, %.3f): %.3f\n"
+                % (len(positions), sensor_pos[0], sensor_pos[1], pos))
+        # Calculate maximum, minimum and average values
+        max_value = max(positions)
+        min_value = min(positions)
+        range_value = max_value - min_value
+        avg_value = self._calc_mean(positions)
+        median = self._calc_median(positions)
+        # calculate the standard deviation
+        deviation_sum = 0
+        for i in range(len(positions)):
+            deviation_sum += pow(positions[i] - avg_value, 2.)
+        sigma = (deviation_sum / len(positions)) ** 0.5
+        # Show information
+        gcmd.respond_info(
+            "probe accuracy results: maximum %.6f, minimum %.6f, range %.6f, "
+            "average %.6f, median %.6f, standard deviation %.6f" % (
+            max_value, min_value, range_value, avg_value, median, sigma))
+
+
+def load_config(config):
+    prt = PRTouchZOffsetWrapper(config)
+    return prt
+
+# PRTOUCH_PROBE_ZOFFSET APPLY_Z_ADJUST=1
diff --git a/klippy/extras/serial_bridge.py b/klippy/extras/serial_bridge.py
new file mode 100644
index 000000000..a7259f6fc
--- /dev/null
+++ b/klippy/extras/serial_bridge.py
@@ -0,0 +1,192 @@
+# Support for "serial bridge"
+#
+# Copyright (C) 2019-2020  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, re
+
+QUERY_TIME = 0.2
+
+class SerialBridge:
+    def __init__(self, config):
+        self.mcus = {}
+        self.configs = []
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object("gcode")
+        self.gcode.register_command("SERIAL_BRIDGE_SEND",
+            self.cmd_SERIAL_BRIDGE_SEND,
+            desc="Send a message to a uart bridge")
+        self.gcode.register_command("SERIAL_BRIDGE_LIST_CONFIGS",
+            self.cmd_SERIAL_BRIDGE_LIST_CONFIGS,
+            desc="List Available serial configs")
+        self.gcode.register_command("SERIAL_BRIDGE_LIST_BRIDGES",
+            self.cmd_SERIAL_BRIDGE_LIST_BRIDGES,
+            desc="List current bridges")
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.printer.register_event_handler("klippy:disconnect",
+            self.handle_disconnect)
+        self.bridges = {}
+
+    def handle_ready(self):
+        self._ready = True
+
+        self.mcus = self.printer.lookup_objects('mcu')
+
+        self.configs = []
+        for n, mcu in self.mcus:
+            constants = mcu.get_constants()
+            configs= (
+                ["%s=%s" % (k, v) for k,v in constants.items() \
+                    if k.startswith("SERIAL_BRIDGE_CONFIG")])
+
+            self.configs.extend(configs)
+            logging.info("Serial bridge: available configs for %s: " % (n)
+                 + ", ".join(configs))
+
+    def handle_disconnect(self):
+        pass
+
+    def setup_bridge(self, bridge):
+        self.bridges[bridge.name.split()[-1]] = bridge
+
+    def cmd_SERIAL_BRIDGE_LIST_CONFIGS(self, gcmd):
+        gcmd.respond_info((", ".join(self.configs)))
+
+    def cmd_SERIAL_BRIDGE_LIST_BRIDGES(self, gcmd):
+        gcmd.respond_info((", ".join(self.bridges.keys())))
+
+    def cmd_SERIAL_BRIDGE_SEND(self, gcmd):
+        text = gcmd.get("TEXT")
+        bridge = gcmd.get("BRIDGE")
+
+        if not bridge:
+            gcmd.respond_info("BRIDGE is required")
+            return
+
+        if bridge not in self.bridges:
+            gcmd.respond_info("BRIDGE not found")
+            return
+
+        self.bridges[bridge].send_serial(
+            self.perform_replacement(gcmd.get("TEXT")))
+
+    def get_configs(self):
+        return self.configs
+
+    def perform_replacement(self, input_string):
+        # Find all occurrences of "\x" followed by two hexadecimal digits
+        hex_matches = re.finditer(r'\\x([0-9a-fA-F]{2})', input_string)
+
+        # Replace each matched hex sequence with its corresponding bytes
+        replaced_bytes = bytearray()
+        last_index = 0
+
+        for match in hex_matches:
+            hex_value = match.group(1)
+            byte_value = bytearray.fromhex(hex_value)
+            replaced_bytes.extend(byte_value)
+            last_index = match.end()
+
+        replaced_bytes.extend(input_string[last_index:].encode('utf-8'))
+
+        return replaced_bytes
+
+class PrinterSerialBridge:
+    def __init__(self, config):
+        self.callbacks = []
+        self.printer = config.get_printer()
+        self.name = config.get_name().split()[-1]
+        self.eol = config.get('eol', default='\n')
+        self._ready = False
+        self.baud = config.getint("baud", 115200)
+        self.serial_config = config.getint("config", 4)
+        self._logging = config.getboolean("logging", False)
+
+        self.reactor = self.printer.get_reactor()
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.printer.register_event_handler("klippy:disconnect",
+            self.handle_disconnect)
+
+        ppins = self.printer.lookup_object("pins")
+        pin_params = ppins.lookup_pin(config.get("tx_pin"))
+        rx_pin_params = ppins.lookup_pin(config.get("rx_pin"))
+        self.mcu = pin_params['chip']
+        self.oid = self.mcu.create_oid()
+        self.mcu.register_config_callback(self.build_config)
+
+        self.input_buffer = ""
+
+        self.serial_bridge = self.printer.load_object(config, "serial_bridge")
+        self.serial_bridge.setup_bridge(self)
+
+    def register_callback(self, callback):
+        self.callbacks.append(callback)
+
+    def chunkstring(self, msg, length):
+        return (msg[0+i:length+i] for i in range(0, len(msg), length))
+
+    def send_text(self, msg):
+        self.send_serial(msg.encode('utf-8'))
+    
+    def write(self, msg):
+        #byte_debug = ' '.join(['0x{:02x}'.format(byte) for byte in msg])
+        #self.log("Sending bytes: " + byte_debug)
+        self.serial_bridge_send_cmd.send([self.oid, msg, 4])
+
+
+    def send_serial(self, msg):
+        if not self._ready:
+            self.warn("Can't send message in a disconnected state")
+            return
+
+        chunks = self.chunkstring(
+            msg + self.serial_bridge.perform_replacement(self.eol), 40)
+        for chunk in chunks:
+            byte_debug = ' '.join(['0x{:02x}'.format(byte) for byte in chunk])
+            self.log("Sending message: " + byte_debug)
+            self.serial_bridge_send_cmd.send([self.oid, chunk, 4])
+
+    def build_config(self):
+        rest_ticks = self.mcu.seconds_to_clock(QUERY_TIME)
+        clock = self.mcu.get_query_slot(self.oid)
+        self.mcu.add_config_cmd(
+            "command_config_serial_bridge oid=%d clock=%d rest_ticks=%d "\
+                "config=%d baud=%d" % (
+                    self.oid, clock, rest_ticks, self.serial_config, self.baud
+                ))
+
+        cmd_queue = self.mcu.alloc_command_queue()
+
+        self.mcu.register_response(self._handle_serial_bridge_response,
+            "serial_bridge_response", self.oid)
+        self.serial_bridge_send_cmd = self.mcu.lookup_command(
+            "serial_bridge_send oid=%c text=%*s",
+            cq=cmd_queue)
+
+    def _handle_serial_bridge_response(self, params):
+        data = params["text"]
+
+        data = bytearray(data)
+
+        for callback in self.callbacks:
+            callback(data)
+
+    def handle_ready(self):
+        self.log("Ready")
+        self._ready = True
+
+    def handle_disconnect(self):
+        self._ready = False
+
+    def log(self, msg, *args, **kwargs):
+        if self._logging:
+            logging.info("SERIAL BRIDGE %s: " % (self.name) + str(msg) )
+
+    def warn(self, msg, *args, **kwargs):
+        logging.warning("SERIAL BRIDGE %s: " % (self.name) + str(msg))
+
+def load_config(config):
+    return SerialBridge(config)
+
+def load_config_prefix(config):
+    return PrinterSerialBridge(config)
\ No newline at end of file
diff --git a/klippy/stepper.py b/klippy/stepper.py
index 56c8ec758..a6aa25eb7 100644
--- a/klippy/stepper.py
+++ b/klippy/stepper.py
@@ -58,6 +58,8 @@ class MCU_stepper:
         if short and self._name.startswith('stepper_'):
             return self._name[8:]
         return self._name
+    def get_pin_info(self):
+        return self._dir_pin, self._step_pin, self._invert_dir, self._invert_step
     def units_in_radians(self):
         # Returns true if distances are in radians instead of millimeters
         return self._units_in_radians
diff --git a/src/Makefile b/src/Makefile
index ed98172e4..6b70e7b78 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,8 +1,9 @@
 # Main code build rules
 
 src-y += sched.c command.c basecmd.c debugcmds.c
+src-$(CONFIG_SERIAL_BRIDGE) += serial_bridge.c
 src-$(CONFIG_HAVE_GPIO) += initial_pins.c gpiocmds.c stepper.c endstop.c \
-    trsync.c
+    trsync.c dirzctl.c hx711s.c
 src-$(CONFIG_HAVE_GPIO_ADC) += adccmds.c
 src-$(CONFIG_HAVE_GPIO_SPI) += spicmds.c
 src-$(CONFIG_HAVE_GPIO_SDIO) += sdiocmds.c
diff --git a/src/dirzctl.c b/src/dirzctl.c
new file mode 100755
index 000000000..befc27978
--- /dev/null
+++ b/src/dirzctl.c
@@ -0,0 +1,200 @@
+#include "autoconf.h" // CONFIG_CLOCK_FREQ
+#include "basecmd.h"        // oid_alloc
+#include "board/gpio.h"     // struct gpio_in
+#include "board/irq.h"      // irq_disable
+#include "board/misc.h"     // timer_from_us
+#include "board/internal.h" // gpio_peripheral
+#include "command.h"        // DECL_COMMAND
+#include "sched.h"          // struct timer
+#include <stdio.h>
+#include <string.h>
+
+#define TICKS_LEN 32
+
+struct dirzctl
+{
+    struct timer time;
+
+    uint32_t oid;
+    uint32_t count;
+    int32_t dir_inverts[4];
+    int32_t step_invrets[4];
+    struct gpio_out dirs[4];
+    struct gpio_out steps[4];
+    struct gpio_in in_dirs[4];
+
+    uint32_t r_steps;
+    uint32_t r_steps_fix;
+    uint32_t n_ticks;
+    uint32_t o_dirs[4];
+
+    uint32_t r_stop;
+
+    uint32_t a_finish;
+    uint32_t a_steps;
+    uint32_t a_ticks;
+};
+
+struct task_wake dirzctl_wake;
+
+//struct dirzctl *d = NULL;
+void 
+command_config_dirzctl(uint32_t *args);
+
+static void 
+deal_dirs(struct dirzctl *d, int32_t dir, int32_t is_save)
+{
+    if (is_save > 0)
+    {
+        for (int32_t i = 0; i < d->count; i++)
+        {
+            d->o_dirs[i] = gpio_in_read(d->in_dirs[i]);
+            gpio_out_write(d->dirs[i], (dir != d->dir_inverts[i]));
+        }
+    }
+    else
+    {
+        for (int32_t i = 0; i < d->count; i++)
+            gpio_out_write(d->dirs[i], d->o_dirs[i]);
+    }
+}
+
+static void 
+deal_steps(struct dirzctl *d)
+{
+	for (int i = 0; i < d->count; i++)
+        gpio_out_toggle_noirq(d->steps[i]);
+}
+
+static void 
+send_status(struct dirzctl *d)
+{
+    d->a_ticks = timer_read_time();
+    d->a_steps = (d->r_steps - (d->r_steps % 2)) / 2;
+    d->a_finish = 1;
+}
+
+static uint_fast8_t 
+dirzctl_event(struct timer *t)
+{
+	struct dirzctl *d = container_of(t,struct dirzctl,time);
+
+    sched_wake_task(&dirzctl_wake);
+	deal_steps(d);
+    d->r_steps--;
+    if((d->r_steps == 0) || ((d->r_steps % 2 == 0) && (d->r_stop == 1)))
+    {
+        sched_del_timer(&d->time);
+        send_status(d);
+        deal_dirs(d,0, 0);
+        d->r_stop = 0;
+        return SF_DONE;        
+    }else if(d->r_steps == d->r_steps_fix - 1)
+        send_status(d);
+    d->time.waketime = timer_read_time() + d->n_ticks;
+    return SF_RESCHEDULE;
+}
+
+void 
+command_config_dirzctl(uint32_t *args)
+{
+    sendf("debug_dirzctl oid=%c arg[0]=%u arg[1]=%u arg[2]=%u arg[3]=%u arg[4]=%u arg[5]=%u", 
+        (uint8_t)args[0], (uint32_t)args[0], (uint32_t)args[1], (uint32_t)args[2], (uint32_t)args[3], (uint32_t)args[4], (uint32_t)args[5]);
+    struct dirzctl* d = oid_alloc(args[0], command_config_dirzctl, sizeof(*d));
+    d->oid = args[0];
+    d->count = args[1];
+    d->a_finish = 0;
+    d->r_stop = 0;
+    if (d->count > 4)
+        shutdown("Max of 4 Z AXIS");
+    d->time.func = dirzctl_event;
+}
+DECL_COMMAND(command_config_dirzctl, "config_dirzctl oid=%c z_count=%c");
+
+void 
+command_add_dirzctl(uint32_t *args)
+{
+    uint8_t index = args[1];
+	uint8_t oid = args[0];
+	struct dirzctl* d = oid_lookup(oid,command_config_dirzctl);
+
+    sendf("debug_dirzctl oid=%c arg[0]=%u arg[1]=%u arg[2]=%u arg[3]=%u arg[4]=%u arg[5]=%u", 
+        (uint8_t)args[0], (uint32_t)args[0], (uint32_t)args[1], (uint32_t)args[2], (uint32_t)args[3], (uint32_t)args[4], (uint32_t)args[5]);
+    if (index >= 4)
+        shutdown("Set direct z ctl maximum count");
+    d->dir_inverts[index] = args[4];
+    d->step_invrets[index] = args[5];
+    d->in_dirs[index] = gpio_in_setup(args[2], 0);
+    d->dirs[index] = gpio_out_setup(args[2], 0);
+    d->steps[index] = gpio_out_setup(args[3], args[5]);
+}
+DECL_COMMAND(command_add_dirzctl, "add_dirzctl oid=%c index=%c dir_pin=%u step_pin=%u dir_invert=%c step_invert=%c");
+
+void 
+command_run_dirzctl(uint32_t *args)
+{
+    //sendf("debug_dirzctl oid=%c arg[0]=%u arg[1]=%u arg[2]=%u arg[3]=%u arg[4]=%u arg[5]=%u", 
+    //   (uint8_t)args[0], (uint32_t)args[0], (uint32_t)args[1], (uint32_t)args[2], (uint32_t)args[3], (uint32_t)args[4], (uint32_t)args[5]);
+	uint8_t oid = args[0];
+	struct dirzctl* d = oid_lookup(oid,command_config_dirzctl);
+    
+	if(args[3] == 0)
+    {
+        d->r_stop = 1;
+        return;
+    }    
+    d->r_stop = 0;
+    deal_dirs(d,args[1], 1);    
+    d->n_ticks = (uint32_t)(((double)args[2] / 1000000) * CONFIG_CLOCK_FREQ) / 2; 
+    d->r_steps = args[3] * 2;
+    d->r_steps_fix = d->r_steps;
+    d->time.waketime = timer_read_time() + d->n_ticks;
+    sched_add_timer(&d->time);
+}
+DECL_COMMAND(command_run_dirzctl, "run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u");
+
+void 
+dirzctl_task(void)
+{
+	uint8_t oid;
+
+	struct dirzctl* d;
+
+	if(!sched_check_wake(&dirzctl_wake))
+	{
+		return;
+	}
+	
+	foreach_oid(oid,d,command_config_dirzctl)
+	{
+
+		if(d->a_finish == 0)
+		{
+			return;
+		}
+
+		sendf("result_dirzctl oid=%c step=%u tick=%u", (uint8_t)d->oid, (uint16_t)d->a_steps, (uint32_t)d->a_ticks);
+		
+		d->a_finish = 0;
+	}
+	return;
+}
+DECL_TASK(dirzctl_task);
+
+void 
+dirzctl_shutdown(void)
+{
+	uint8_t oid;
+
+	struct dirzctl* d;
+
+	foreach_oid(oid,d,command_config_dirzctl)
+	{
+		d->a_finish = 0;
+	}
+
+	return;
+}
+
+DECL_SHUTDOWN(dirzctl_shutdown);
+
diff --git a/src/generic/serial_bridge_irq.c b/src/generic/serial_bridge_irq.c
new file mode 100644
index 000000000..3e9d7029f
--- /dev/null
+++ b/src/generic/serial_bridge_irq.c
@@ -0,0 +1,119 @@
+// Generic interrupt based serial uart helper code
+//
+// Copyright (C) 2016-2018  Kevin O'Connor <kevin@koconnor.net>
+//
+// This file may be distributed under the terms of the GNU GPLv3 license.
+
+#include <string.h> // memmove
+#include "autoconf.h" // CONFIG_SERIAL_BAUD
+#include "board/io.h" // readb
+#include "board/irq.h" // irq_save
+#include "board/misc.h" // console_sendf
+#include "board/pgm.h" // READP
+#include "command.h" // DECL_CONSTANT
+#include "sched.h" // sched_wake_tasks
+#include "serial_bridge_irq.h" // serial_enable_tx_irq
+#include "board/serial_bridge.h" //SERIAL_BRIDGE_CNT
+
+static uint8_t receive_bridge_buf
+        [SERIAL_BRIDGE_CNT][SERIAL_BRIDGE_RX_BUFF_SIZE],
+        receive_bridge_pos[SERIAL_BRIDGE_CNT];
+static uint8_t transmit_bridge_buf
+        [SERIAL_BRIDGE_CNT][SERIAL_BRIDGE_RX_BUFF_SIZE],
+transmit_bridge_pos[SERIAL_BRIDGE_CNT], transmit_bridge_max[SERIAL_BRIDGE_CNT];
+
+void serial_bridge_rx_byte(uint_fast8_t data, uint8_t usart_index) {
+    if (receive_bridge_pos[usart_index] >= SERIAL_BRIDGE_RX_BUFF_SIZE)
+        // Serial overflow - ignore
+        return;
+    sched_wake_tasks();
+    receive_bridge_buf[usart_index][receive_bridge_pos[usart_index]++] = data;
+}
+
+int serial_bridge_get_tx_byte(uint8_t *pdata, uint8_t usart_index) {
+    if (transmit_bridge_pos[usart_index] >= transmit_bridge_max[usart_index])
+        return -1;
+    *pdata =
+        transmit_bridge_buf[usart_index][transmit_bridge_pos[usart_index]++];
+    return 0;
+}
+
+void
+serial_bridge_send(uint8_t* data, uint_fast8_t size, uint8_t config)
+{
+    uint8_t* usart_index_ptr
+        = serial_bridge_get_uart_index_from_config(config);
+
+    if(usart_index_ptr == NULL){
+        return;
+    }
+
+    uint8_t usart_index = *usart_index_ptr;
+
+    // Verify space for message
+    uint_fast8_t tpos =
+        readb(&transmit_bridge_pos[usart_index]),
+        tmax = readb(&transmit_bridge_max[usart_index]);
+
+    if (tpos >= tmax) {
+        tpos = tmax = 0;
+        writeb(&transmit_bridge_max[usart_index], 0);
+        writeb(&transmit_bridge_pos[usart_index], 0);
+    }
+
+    if (tmax + size > sizeof(transmit_bridge_buf[usart_index])) {
+        if (tmax + size - tpos > sizeof(transmit_bridge_buf[usart_index]))
+            // Not enough space for message
+            return;
+        // Disable TX irq and move usart_index
+        writeb(&transmit_bridge_max[usart_index], 0);
+        tpos = readb(&transmit_bridge_pos[usart_index]);
+        tmax -= tpos;
+        memmove(&transmit_bridge_buf[usart_index][0],
+            &transmit_bridge_buf[usart_index][tpos], tmax);
+        writeb(&transmit_bridge_pos[usart_index], 0);
+        writeb(&transmit_bridge_max[usart_index], tmax);
+        serial_bridge_enable_tx_irq(usart_index);
+    }
+
+    // Generate message
+    uint8_t *buf = &transmit_bridge_buf[usart_index][tmax];
+    memcpy(buf, data, size);
+
+    // Start message transmit
+    writeb(&transmit_bridge_max[usart_index], tmax + size);
+    serial_bridge_enable_tx_irq(usart_index);
+}
+
+// Remove from the receive buffer the given number of bytes
+uint8_t
+serial_bridge_get_data(uint8_t* data, uint8_t config)
+{
+    uint8_t* usart_index_ptr
+        = serial_bridge_get_uart_index_from_config(config);
+
+    if(usart_index_ptr == NULL){
+        return 0;
+    }
+
+    uint8_t usart_index = *usart_index_ptr;
+
+    for (;;) {
+        uint_fast8_t rpos = readb(&receive_bridge_pos[usart_index]);
+        if (!rpos)
+            return 0;
+
+        uint8_t *buf = receive_bridge_buf[usart_index];
+        memcpy(data, buf, rpos);
+        irqstatus_t flag = irq_save();
+        if (rpos != readb(&receive_bridge_pos[usart_index])) {
+            // Raced with irq handler - retry
+            irq_restore(flag);
+            continue;
+        }
+        receive_bridge_pos[usart_index] = 0;
+        irq_restore(flag);
+
+        return rpos;
+    }
+}
\ No newline at end of file
diff --git a/src/hx711s.c b/src/hx711s.c
new file mode 100755
index 000000000..fd1caa9a1
--- /dev/null
+++ b/src/hx711s.c
@@ -0,0 +1,189 @@
+#include "autoconf.h" // CONFIG_CLOCK_FREQ
+#include "basecmd.h"        // oid_alloc
+#include "board/gpio.h"     // struct gpio_in
+#include "board/irq.h"      // irq_disable
+#include "board/misc.h"     // timer_from_us
+#include "board/internal.h" // gpio_peripheral
+#include "command.h"        // DECL_COMMAND
+#include "sched.h"          // struct timer
+#include <stdio.h>
+#include <string.h>
+
+#define HX711S_SAMPLE_PERIOD_TICKS			(CONFIG_CLOCK_FREQ / 10000 * 125)
+#define HX711S_SAMPLE_REST_TICKS			(HX711S_SAMPLE_PERIOD_TICKS / 2)
+
+struct hx711s
+{
+	struct timer hx711s_timer;
+    uint32_t oid; 
+ 	uint32_t rest_ticks;
+	uint8_t flags;	
+    uint32_t hx711_count;
+    int32_t  times_read;
+    struct gpio_out clks[4];
+    struct gpio_in sdos[4];
+};
+
+struct task_wake hx711s_wake;
+
+enum {HX711S_SAMPLE_START = 1 << 0};
+
+static uint_fast8_t
+hx711s_sample_event(struct timer* t)
+{
+	sched_wake_task(&hx711s_wake);
+
+	struct hx711s* h = container_of(t,struct hx711s,hx711s_timer);
+
+	h->hx711s_timer.waketime += h->rest_ticks;
+
+	if(h->flags & HX711S_SAMPLE_START)
+	{
+		return SF_RESCHEDULE;
+	}
+
+	return SF_DONE;
+}
+
+
+void 
+command_config_hx711s(uint32_t *args)
+{
+    struct hx711s* h = oid_alloc(args[0], command_config_hx711s, sizeof(*h));
+    h->oid = args[0];
+    h->hx711_count = args[1];
+    if (h->hx711_count > 4)
+        shutdown("Max of 4 hx711");
+	h->flags = 0;
+	h->rest_ticks = HX711S_SAMPLE_REST_TICKS;
+	h->hx711s_timer.func = hx711s_sample_event;
+    sendf("debug_hx711s oid=%c arg[0]=%u arg[1]=%u arg[2]=%u arg[3]=%u", (int)args[0], (int)args[0], (int)args[1], 0, 0);
+}
+DECL_COMMAND(command_config_hx711s, "config_hx711s oid=%c hx711_count=%c");
+
+static int32_t 
+get_hx711s(struct hx711s* h)
+{
+    static uint64_t last_tick = 0;    
+    int32_t outVals[4] = {0, 0, 0, 0}, is_data_valid = 0;
+
+    for (int j = 0; j < h->hx711_count; j++)
+        is_data_valid |= (gpio_in_read(h->sdos[j]) << j);
+
+    uint64_t now_tick = timer_read_time();
+    now_tick += (now_tick < last_tick ? 0xFFFFFFFF : 0);
+    uint64_t now_inter_ms = (now_tick - last_tick) * 1000.0f / CONFIG_CLOCK_FREQ;
+
+    //if (is_data_valid == 0 || now_inter_ms >= 25)
+    if (is_data_valid == 0)
+    {
+        for (int j = 0; j < h->hx711_count; j++)
+            gpio_out_write(h->clks[j], 0);
+
+        for (int i = 0; i < 24; i++)
+        {
+            for (int j = 0; j < h->hx711_count; j++)
+                gpio_out_write(h->clks[j], 1);
+            for (int j = 0; j < h->hx711_count; j++)
+                outVals[j] = outVals[j] << 1;
+            for (int j = 0; j < h->hx711_count; j++)
+                gpio_out_write(h->clks[j], 0);
+            for (int j = 0; j < h->hx711_count; j++)
+                outVals[j] += (gpio_in_read(h->sdos[j]) > 0 ? 1 : 0);
+        }
+        for (int j = 0; j < h->hx711_count; j++)
+            gpio_out_write(h->clks[j], 1);
+        for (int j = 0; j < h->hx711_count; j++)
+        {
+            outVals[j] |= ((outVals[j] & 0x00800000) != 0 ? 0xFF000000 : 0);
+        }
+        for (int j = 0; j < h->hx711_count; j++)
+            gpio_out_write(h->clks[j], 0);
+
+        last_tick = timer_read_time();
+        sendf("result_hx711s oid=%c vd=%c it=%c tr=%hu nt=%u v0=%i v1=%i v2=%i v3=%i", 
+                             (uint8_t)h->oid, (uint8_t)is_data_valid, (uint8_t)now_inter_ms, (uint16_t)h->times_read, (uint32_t)now_tick,  (int32_t)outVals[0], (int32_t)outVals[1], (int32_t)outVals[2], (int32_t)outVals[3]);
+        return 1;  
+    }
+    return 0;
+}
+
+
+void 
+command_add_hx711s(uint32_t *args)
+{
+	uint8_t oid = args[0];
+    uint8_t index = args[1];
+	struct hx711s* h = oid_lookup(oid,command_config_hx711s);	
+    if (index >= h->hx711_count)
+        shutdown("Set hx711 past maximum count");
+
+    h->clks[index] = gpio_out_setup(args[2], 0);
+    h->sdos[index] = gpio_in_setup(args[3], 0);
+
+    sendf("debug_hx711s oid=%c arg[0]=%u arg[1]=%u arg[2]=%u arg[3]=%u", (int)args[0], (int)args[0], (int)args[1], (int)args[2], (int)args[3]);
+}
+DECL_COMMAND(command_add_hx711s, "add_hx711s oid=%c index=%c clk_pin=%u sdo_pin=%u");
+
+void 
+command_query_hx711s(uint32_t *args)
+{
+	uint8_t oid = args[0];
+	struct hx711s* h = oid_lookup(oid,command_config_hx711s);	
+	h->times_read = args[1];
+	h->flags |= HX711S_SAMPLE_START;
+	sched_del_timer(&h->hx711s_timer);
+	irq_disable();
+	h->hx711s_timer.waketime = timer_read_time() + h->rest_ticks;
+	sched_add_timer(&h->hx711s_timer);
+	irq_enable();
+}
+DECL_COMMAND(command_query_hx711s, "query_hx711s oid=%c times_read=%hu");
+
+
+void 
+hx711s_task(void)
+{
+	uint8_t oid;
+	struct hx711s* h;
+
+	if(!sched_check_wake(&hx711s_wake))
+	{
+		return;
+	}
+
+	foreach_oid(oid,h,command_config_hx711s)
+	{
+    	if (!(h->flags & HX711S_SAMPLE_START) || h->times_read <= 0)
+        {
+			return;
+		}		
+
+    	if(get_hx711s(h) > 0)
+		{
+        	h->times_read--;
+			if(h->times_read == 0)
+			{
+				h->flags &= ~HX711S_SAMPLE_START;
+				//sched_del_timer(&h->hx711s_timer);	
+			}
+		}
+	}
+}
+DECL_TASK(hx711s_task);
+
+void 
+hx711s_shutdown(void)
+{
+	uint8_t oid;
+	struct hx711s* h;
+	foreach_oid(oid,h,command_config_hx711s)
+	{
+		h->times_read = 0;
+		h->flags &= ~HX711S_SAMPLE_START;
+	}
+	return;	
+}
+
+DECL_SHUTDOWN(hx711s_shutdown);
+
diff --git a/src/serial_bridge.c b/src/serial_bridge.c
new file mode 100644
index 000000000..9754a58ec
--- /dev/null
+++ b/src/serial_bridge.c
@@ -0,0 +1,86 @@
+// Support for serial port bridging
+//
+// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
+//
+// This file may be distributed under the terms of the GNU GPLv3 license.
+
+#include <string.h> // memcpy
+#include "autoconf.h" // CONFIG_MACH_AVR
+#include "board/gpio.h" // gpio_out_write
+#include "board/irq.h" // irq_poll
+#include "board/misc.h" // timer_read_time
+#include "board/io.h" // readb
+#include "generic/serial_bridge_irq.h" // console2_sendf
+#include "basecmd.h" // oid_alloc
+#include "command.h" // DECL_COMMAND
+#include "sched.h" // sched_shutdown
+
+struct serial_bridge {
+    struct timer timer;
+    uint8_t config;
+    uint32_t baud;
+    uint32_t rest_time;
+};
+
+static struct task_wake serial_bridge_wake;
+
+static uint_fast8_t serial_bridge_event(struct timer *timer) {
+    struct serial_bridge *bridge = container_of(
+            timer, struct serial_bridge, timer);
+
+    sched_wake_task(&serial_bridge_wake);
+
+    bridge->timer.waketime += bridge->rest_time;
+
+    return SF_RESCHEDULE;
+}
+
+void
+command_config_serial_bridge(uint32_t *args)
+{
+    struct serial_bridge *bridge = oid_alloc(
+        args[0], command_config_serial_bridge, sizeof(*bridge));
+    bridge->timer.func = serial_bridge_event;
+    bridge->timer.waketime = args[1];
+    bridge->rest_time = args[2];
+    bridge->config = args[3];
+    bridge->baud = args[4];
+
+    serial_bridge_configure(&bridge->config, &bridge->baud);
+    sched_add_timer(&bridge->timer);
+}
+DECL_COMMAND(command_config_serial_bridge,
+            "command_config_serial_bridge oid=%c clock=%u"
+                " rest_ticks=%u config=%c baud=%u");
+
+void
+command_serial_bridge_send(uint32_t *args)
+{
+    struct serial_bridge *sb = oid_lookup(args[0],
+        command_config_serial_bridge);
+    uint8_t data_len = args[1];
+    uint8_t *data = command_decode_ptr(args[2]);
+
+    serial_bridge_send(data, data_len, sb->config);
+}
+DECL_COMMAND(command_serial_bridge_send, "serial_bridge_send oid=%c text=%*s");
+
+void
+serial_bridge_task(void)
+{
+    if (!sched_check_wake(&serial_bridge_wake))
+        return;
+
+    static uint8_t buf[SERIAL_BRIDGE_RX_BUFF_SIZE];
+
+    uint8_t oid;
+    struct serial_bridge *sb;
+    foreach_oid(oid, sb, command_config_serial_bridge) {
+        uint32_t data_len = serial_bridge_get_data(buf, sb->config);
+        if (data_len) {
+            sendf("serial_bridge_response oid=%c text=%*s",
+                oid, (uint8_t)data_len, buf);
+        }
+    }
+}
+DECL_TASK(serial_bridge_task);
\ No newline at end of file
diff --git a/src/stm32/Kconfig b/src/stm32/Kconfig
index dbd6ff959..2a3ca90ec 100644
--- a/src/stm32/Kconfig
+++ b/src/stm32/Kconfig
@@ -501,6 +501,20 @@ choice
         depends on HAVE_STM32_FDCANBUS
 endchoice
 
+config SERIAL_BRIDGE
+    bool "Enable serial bridge" if LOW_LEVEL_OPTIONS
+    depends on MACH_STM32
+    default n
+
+config ENABLE_SERIAL_BRIDGE_USART1
+    bool "USART1" if SERIAL_BRIDGE && !(STM32_SERIAL_USART1 || STM32_SERIAL_USART1_ALT_PB7_PB6)
+    depends on SERIAL_BRIDGE
+config ENABLE_SERIAL_BRIDGE_USART2
+    bool "USART2" if SERIAL_BRIDGE && !(STM32_SERIAL_USART2 || STM32_SERIAL_USART2_ALT_PA15_PA14 || STM32_SERIAL_USART2_ALT_PB4_PB3 || STM32_SERIAL_USART2_ALT_PD6_PD5)
+    depends on SERIAL_BRIDGE
+config ENABLE_SERIAL_BRIDGE_USART6
+    bool "USART6" if SERIAL_BRIDGE
+    depends on SERIAL_BRIDGE
 
 config STM32_CANBUS_PB8_PB9
     bool
diff --git a/src/stm32/Makefile b/src/stm32/Makefile
index 18af2e9d7..97a1b7808 100644
--- a/src/stm32/Makefile
+++ b/src/stm32/Makefile
@@ -94,6 +94,9 @@ src-$(CONFIG_USBCANBUS) += $(usb-src-y) $(canbus-src-y)
 src-$(CONFIG_USBCANBUS) += stm32/chipid.c generic/usb_canbus.c
 src-$(CONFIG_HAVE_GPIO_HARD_PWM) += stm32/hard_pwm.c
 
+src-$(CONFIG_SERIAL_BRIDGE) += stm32/serial_bridge.c generic/serial_bridge_irq.c
+
+
 # Binary output file rules
 target-y += $(OUT)klipper.bin
 
diff --git a/src/stm32/serial_bridge.c b/src/stm32/serial_bridge.c
new file mode 100644
index 000000000..4a5bbb8b7
--- /dev/null
+++ b/src/stm32/serial_bridge.c
@@ -0,0 +1,238 @@
+// STM32 serial
+//
+// Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
+//
+// This file may be distributed under the terms of the GNU GPLv3 license.
+
+#include "autoconf.h" // CONFIG_SERIAL_BAUD
+#include "board/armcm_boot.h" // armcm_enable_irq
+#include "board/serial_bridge_irq.h" // serial_rx_byte
+#include "command.h" // DECL_CONSTANT_STR
+#include "internal.h" // enable_pclock
+#include "sched.h" // DECL_INIT
+#include "board/gpio.h"
+#include "board/serial_bridge.h"
+
+#define CR1_FLAGS (USART_CR1_UE | USART_CR1_RE | USART_CR1_TE   \
+                   | USART_CR1_RXNEIE)
+
+typedef struct serial_bridge_config {
+    uint8_t number;
+    USART_TypeDef* usart;
+    uint8_t rx_pin;
+    uint8_t tx_pin;
+    uint8_t rx_alt_function;
+    uint8_t tx_alt_function;
+    uint32_t baud;
+    uint8_t active;
+    uint8_t usart_index;
+} serial_bridge_config_t;
+
+
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART1
+DECL_CONSTANT("SERIAL_BRIDGE_CONFIG_USART1_PA3,PA2", 0);
+DECL_CONSTANT("SERIAL_BRIDGE_CONFIG_USART1_PB7,PB6", 1);
+#endif
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART2
+DECL_CONSTANT("SERIAL_BRIDGE_CONFIG_USART2_PD6,PD5", 2);
+DECL_CONSTANT("SERIAL_BRIDGE_CONFIG_USART2_PA3,PA2", 3);
+#endif
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART6
+DECL_CONSTANT("SERIAL_BRIDGE_CONFIG_USART6_PA12,PA11", 4);
+#endif
+
+USART_TypeDef* usarts[] = {
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART1
+    USART1,
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART2
+    USART2,
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART6
+    USART6,
+    #endif
+};
+
+serial_bridge_config_t configs[] = {
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART1
+    {
+        0,
+        USART1,
+        GPIO('A', 3),
+        GPIO('A', 2),
+        7,
+        7
+    },
+    {
+        1,
+        USART1,
+        GPIO('B', 7),
+        GPIO('B', 6),
+        7,
+        7
+    },
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART2
+    {
+        2,
+        USART2,
+        GPIO('D', 6),
+        GPIO('D', 5),
+        7,
+        7
+    },
+    {
+        3,
+        USART2,
+        GPIO('A', 3),
+        GPIO('A', 2),
+        7,
+        7
+    },
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART6
+    {
+        4,
+        USART6,
+        GPIO('A', 12),
+        GPIO('A', 11),
+        8,
+        8
+    },
+    #endif
+};
+
+uint8_t* serial_bridge_get_uart_index_from_config(uint8_t config){
+    for(int8_t i = 0; i <  (sizeof(configs) / sizeof(configs[0])); i++){
+        if(configs[i].number == config){
+            return &(configs[i].usart_index);
+        }
+    }
+    return NULL;
+}
+
+serial_bridge_config_t* serial_bridge_get_config_by_number(uint8_t number){
+    for(int8_t i = 0; i <  (sizeof(configs) / sizeof(configs[0])); i++){
+        if(configs[i].number == number){
+            return &configs[i];
+        }
+    }
+    return NULL;
+}
+
+serial_bridge_config_t*
+serial_bridge_get_active_config_for_usart(USART_TypeDef* usart){
+    for(int8_t i = 0; i <  (sizeof(configs) / sizeof(configs[0])); i++){
+        if(configs[i].usart == usart && configs[i].active){
+            return &configs[i];
+        }
+    }
+    return NULL;
+}
+
+void serial_bridge_handle_uart_irq(serial_bridge_config_t* config){
+    uint32_t sr = config->usart->SR;
+    if (sr & (USART_SR_RXNE | USART_SR_ORE)) {
+        // The ORE flag is automatically cleared by reading SR, followed
+        // by reading DR.
+        serial_bridge_rx_byte(config->usart->DR, config->usart_index);
+    }
+    if (sr & USART_SR_TXE && config->usart->CR1 & USART_CR1_TXEIE) {
+        uint8_t data;
+        int ret = serial_bridge_get_tx_byte(&data, config->usart_index);
+        if (ret)
+            config->usart->CR1 = CR1_FLAGS;
+        else
+            config->usart->DR = data;
+    }
+}
+
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART1
+void
+USART1_serial_bridge_IRQHandler(void)
+{
+   serial_bridge_handle_uart_irq(
+        serial_bridge_get_active_config_for_usart(USART1));
+}
+#endif
+
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART2
+void
+USART2_serial_bridge_IRQHandler(void)
+{
+    serial_bridge_handle_uart_irq(
+        serial_bridge_get_active_config_for_usart(USART2));
+}
+#endif
+
+
+#if CONFIG_ENABLE_SERIAL_BRIDGE_USART6
+void
+USART6_serial_bridge_IRQHandler(void)
+{
+    serial_bridge_handle_uart_irq(
+        serial_bridge_get_active_config_for_usart(USART6));
+}
+#endif
+
+void
+serial_bridge_enable_tx_irq(int8_t usart_index)
+{
+    for(int8_t i = 0; i < (sizeof(configs) / sizeof(configs[0])); i++){
+        if(configs[i].usart_index == usart_index && configs[i].active){
+            configs[i].usart->CR1 = CR1_FLAGS | USART_CR1_TXEIE;
+        }
+    }
+}
+
+int8_t
+serial_bridge_configure(uint8_t* config, uint32_t* baud)
+{
+    serial_bridge_config_t* s_config =
+        serial_bridge_get_config_by_number(*config);
+    if (config == NULL) {
+        return -1;
+    }
+    s_config->baud = *baud;
+    s_config->active = 1;
+
+    enable_pclock((uint32_t)s_config->usart);
+
+    uint32_t pclk = get_pclock_frequency((uint32_t)s_config->usart);
+    uint32_t div = DIV_ROUND_CLOSEST(pclk, *baud);
+    s_config->usart->BRR = (((div / 16) << USART_BRR_DIV_Mantissa_Pos)
+                   | ((div % 16) << USART_BRR_DIV_Fraction_Pos));
+    s_config->usart->CR1 = CR1_FLAGS;
+
+    gpio_peripheral(s_config->rx_pin,
+        GPIO_FUNCTION(s_config->rx_alt_function), 1);
+    gpio_peripheral(s_config->tx_pin,
+        GPIO_FUNCTION(s_config->tx_alt_function), 0);
+
+    return 0;
+}
+
+
+void
+serial_bridge_init(void)
+{
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART1
+    armcm_enable_irq(USART1_serial_bridge_IRQHandler, USART1_IRQn, 0);
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART2
+    armcm_enable_irq(USART2_serial_bridge_IRQHandler, USART2_IRQn, 0);
+    #endif
+    #if CONFIG_ENABLE_SERIAL_BRIDGE_USART6
+    armcm_enable_irq(USART6_serial_bridge_IRQHandler, USART6_IRQn, 0);
+    #endif
+
+    //assign indexes for the uart buffers that are in use
+    for(int8_t i = 0; i < sizeof(configs)/sizeof(configs[0]); i++){
+        for(int8_t j = 0; j < sizeof(usarts)/sizeof(usarts[0]); j++){
+            if(usarts[j] == configs[i].usart){
+                configs[i].usart_index = j;
+            }
+        }
+    }
+}
+DECL_INIT(serial_bridge_init);
\ No newline at end of file
