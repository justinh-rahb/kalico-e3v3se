From 43f014d52ecbbefbf088702a21a9967d350d0bc4 Mon Sep 17 00:00:00 2001
From: 0xD34D <clark@scheffsblend.com>
Date: Wed, 13 Dec 2023 12:58:30 -0800
Subject: [PATCH 26/43] Implement PRTOUCH_ACCURACY command

This command takes a number of samples and displays the statistics
of the accuracy of the load cell.

ex.
PRTOUCH_ACCURACY SAMPLES=10 PROBE_SPEED=1
---
 klippy/extras/prtouch.py | 52 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 52 insertions(+)

diff --git a/klippy/extras/prtouch.py b/klippy/extras/prtouch.py
index 495fd3231..c4ab1aa51 100644
--- a/klippy/extras/prtouch.py
+++ b/klippy/extras/prtouch.py
@@ -91,6 +91,7 @@ class PRTouchZOffsetWrapper:
         self.obj.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
         self.obj.gcode.register_command('PRTOUCH_PROBE_ZOFFSET', self.cmd_PRTOUCH_PROBE_ZOFFSET, desc=self.cmd_PRTOUCH_PROBE_ZOFFSET_help)
         self.obj.gcode.register_command('NOZZLE_CLEAR', self.cmd_NOZZLE_CLEAR, desc=self.cmd_NOZZLE_CLEAR_help)
+        self.obj.gcode.register_command('PRTOUCH_ACCURACY', self.cmd_PRTOUCH_ACCURACY, desc=self.cmd_PRTOUCH_ACCURACY_help)
         pass
 
     def _handle_mcu_identify(self):
@@ -209,6 +210,19 @@ class PRTouchZOffsetWrapper:
                 self.obj.hx711s.delay_s(0.100)          
         pass
 
+    def _calc_mean(self, positions):
+        count = float(len(positions))
+        return sum(positions) / count
+
+    def _calc_median(self, positions):
+        z_sorted = sorted(positions)
+        middle = len(positions) // 2
+        if (len(positions) & 1) == 1:
+            # odd number of samples
+            return z_sorted[middle]
+        # even number of samples
+        return self._calc_mean(z_sorted[middle-1:middle+1])
+
     def pnt_msg(self, msg):
         logging.info(msg)
         if self.cfg.show_msg:
@@ -403,6 +417,44 @@ class PRTouchZOffsetWrapper:
         z_probe[2] = homing_origin[2] + z_adjust - start_z_offset
         self.obj.probe.probe_calibrate_finalize(z_probe)
 
+    cmd_PRTOUCH_ACCURACY_help = "Probe Z-height accuracy at sensoor position"
+    def cmd_PRTOUCH_ACCURACY(self, gcmd):
+        self._ck_g28ed()
+        speed = gcmd.get_float("PROBE_SPEED", self.cfg.probe_speed, above=0.)
+        sample_count = gcmd.get_int("SAMPLES", 10, minval=1)
+        gcmd.respond_info("PRTOUCH_ACCURACY at X:%.3f Y:%.3f"
+                          " (samples=%d speed=%.1f)\n"
+                          % (self.cfg.sensor_x, self.cfg.sensor_y,
+                             sample_count, speed))
+        sensor_pos = [self.cfg.sensor_x, self.cfg.sensor_y, self.cfg.bed_max_err]
+        # Move to sensor location
+        self._move(sensor_pos, self.cfg.g29_xy_speed)
+        # Probe bed sample_count times
+        positions = []
+        while len(positions) < sample_count:
+            # Probe position
+            _index1, pos, _sta = self.probe_by_step(sensor_pos, speed, 10, self.cfg.min_hold, self.cfg.max_hold, True)
+            positions.append(pos)
+            gcmd.respond_info(
+                "probe #%d at (%.3f, %.3f): %.3f\n"
+                % (len(positions), sensor_pos[0], sensor_pos[1], pos))
+        # Calculate maximum, minimum and average values
+        max_value = max(positions)
+        min_value = min(positions)
+        range_value = max_value - min_value
+        avg_value = self._calc_mean(positions)
+        median = self._calc_median(positions)
+        # calculate the standard deviation
+        deviation_sum = 0
+        for i in range(len(positions)):
+            deviation_sum += pow(positions[i] - avg_value, 2.)
+        sigma = (deviation_sum / len(positions)) ** 0.5
+        # Show information
+        gcmd.respond_info(
+            "probe accuracy results: maximum %.6f, minimum %.6f, range %.6f, "
+            "average %.6f, median %.6f, standard deviation %.6f" % (
+            max_value, min_value, range_value, avg_value, median, sigma))
+
 
 def load_config(config):
     prt = PRTouchZOffsetWrapper(config)
-- 
2.39.5 (Apple Git-154)

